// Generated by svd2swift.

import MMIO

/// I2C (Inter-Integrated Circuit) Controller 0
@RegisterBlock
public struct I2C0 {
    /// Clock
    @RegisterBlock(offset: 0x0)
    public var scl_low_period: Register<SCL_LOW_PERIOD>

    /// Transmission setting
    @RegisterBlock(offset: 0x4)
    public var ctr: Register<CTR>

    /// Describe I2C work status.
    @RegisterBlock(offset: 0x8)
    public var sr: Register<SR>

    /// Setting time out control for receiving data.
    @RegisterBlock(offset: 0xc)
    public var to: Register<TO>

    /// Local slave address setting
    @RegisterBlock(offset: 0x10)
    public var slave_addr: Register<SLAVE_ADDR>

    /// FIFO status register.
    @RegisterBlock(offset: 0x14)
    public var fifo_st: Register<FIFO_ST>

    /// FIFO configuration register.
    @RegisterBlock(offset: 0x18)
    public var fifo_conf: Register<FIFO_CONF>

    /// Rx FIFO read data.
    @RegisterBlock(offset: 0x1c)
    public var data: Register<DATA>

    /// Raw interrupt status
    @RegisterBlock(offset: 0x20)
    public var int_raw: Register<INT_RAW>

    /// Interrupt clear bits
    @RegisterBlock(offset: 0x24)
    public var int_clr: Register<INT_CLR>

    /// Interrupt enable bits
    @RegisterBlock(offset: 0x28)
    public var int_ena: Register<INT_ENA>

    /// Status of captured I2C communication events
    @RegisterBlock(offset: 0x2c)
    public var int_status: Register<INT_STATUS>

    /// Configures the hold time after a negative SCL edge.
    @RegisterBlock(offset: 0x30)
    public var sda_hold: Register<SDA_HOLD>

    /// Configures the sample time after a positive SCL edge.
    @RegisterBlock(offset: 0x34)
    public var sda_sample: Register<SDA_SAMPLE>

    /// Configures the high level width of SCL
    @RegisterBlock(offset: 0x38)
    public var scl_high_period: Register<SCL_HIGH_PERIOD>

    /// Configures the delay between the SDA and SCL negative edge for a start condition
    @RegisterBlock(offset: 0x40)
    public var scl_start_hold: Register<SCL_START_HOLD>

    /// edge of SCL and the negative edge of SDA
    @RegisterBlock(offset: 0x44)
    public var scl_rstart_setup: Register<SCL_RSTART_SETUP>

    /// edge for a stop condition
    @RegisterBlock(offset: 0x48)
    public var scl_stop_hold: Register<SCL_STOP_HOLD>

    /// SCL positive edge for a stop condition
    @RegisterBlock(offset: 0x4c)
    public var scl_stop_setup: Register<SCL_STOP_SETUP>

    /// SCL and SDA filter configuration register
    @RegisterBlock(offset: 0x50)
    public var filter_cfg: Register<FILTER_CFG>

    /// I2C CLK configuration register
    @RegisterBlock(offset: 0x54)
    public var clk_conf: Register<CLK_CONF>

    /// I2C command register 0
    @RegisterBlock(offset: 0x58)
    public var comd0: Register<COMD0>

    /// I2C command register 1
    @RegisterBlock(offset: 0x5c)
    public var comd1: Register<COMD1>

    /// I2C command register 2
    @RegisterBlock(offset: 0x60)
    public var comd2: Register<COMD2>

    /// I2C command register 3
    @RegisterBlock(offset: 0x64)
    public var comd3: Register<COMD3>

    /// I2C command register 4
    @RegisterBlock(offset: 0x68)
    public var comd4: Register<COMD4>

    /// I2C command register 5
    @RegisterBlock(offset: 0x6c)
    public var comd5: Register<COMD5>

    /// I2C command register 6
    @RegisterBlock(offset: 0x70)
    public var comd6: Register<COMD6>

    /// I2C command register 7
    @RegisterBlock(offset: 0x74)
    public var comd7: Register<COMD7>

    /// SCL status time out register
    @RegisterBlock(offset: 0x78)
    public var scl_st_time_out: Register<SCL_ST_TIME_OUT>

    /// SCL main status time out register
    @RegisterBlock(offset: 0x7c)
    public var scl_main_st_time_out: Register<SCL_MAIN_ST_TIME_OUT>

    /// Power configuration register
    @RegisterBlock(offset: 0x80)
    public var scl_sp_conf: Register<SCL_SP_CONF>

    /// Set SCL stretch of I2C slave
    @RegisterBlock(offset: 0x84)
    public var scl_stretch_conf: Register<SCL_STRETCH_CONF>

    /// Version register
    @RegisterBlock(offset: 0xf8)
    public var date: Register<DATE>

    /// I2C TXFIFO base address register
    @RegisterBlock(offset: 0x100)
    public var txfifo_start_addr: Register<TXFIFO_START_ADDR>

    /// I2C RXFIFO base address register
    @RegisterBlock(offset: 0x180)
    public var rxfifo_start_addr: Register<RXFIFO_START_ADDR>
}

extension I2C0 {
    /// Clock
    @Register(bitWidth: 32)
    public struct SCL_LOW_PERIOD {
        /// This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var scl_low_period_field: SCL_LOW_PERIOD_FIELD
    }

    /// Transmission setting
    @Register(bitWidth: 32)
    public struct CTR {
        /// 1: direct output, 0: open drain output.
        @ReadWrite(bits: 0..<1)
        public var sda_force_out: SDA_FORCE_OUT

        /// 1: direct output, 0: open drain output.
        @ReadWrite(bits: 1..<2)
        public var scl_force_out: SCL_FORCE_OUT

        /// 0: sample SDA data on the SCL high level.
        @ReadWrite(bits: 2..<3)
        public var sample_scl_level: SAMPLE_SCL_LEVEL

        /// This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
        @ReadWrite(bits: 3..<4)
        public var rx_full_ack_level: RX_FULL_ACK_LEVEL

        /// module as an I2C Slave.
        @ReadWrite(bits: 4..<5)
        public var ms_mode: MS_MODE

        /// Set this bit to start sending the data in txfifo.
        @WriteOnly(bits: 5..<6)
        public var trans_start: TRANS_START

        /// 0: send data from the most significant bit.
        @ReadWrite(bits: 6..<7)
        public var tx_lsb_first: TX_LSB_FIRST

        /// 0: receive data from the most significant bit.
        @ReadWrite(bits: 7..<8)
        public var rx_lsb_first: RX_LSB_FIRST

        /// Reserved
        @ReadWrite(bits: 8..<9)
        public var clk_en: CLK_EN

        /// This is the enable bit for arbitration_lost.
        @ReadWrite(bits: 9..<10)
        public var arbitration_en: ARBITRATION_EN

        /// This register is used to reset the scl FMS.
        @WriteOnly(bits: 10..<11)
        public var fsm_rst: FSM_RST

        /// synchronization bit
        @WriteOnly(bits: 11..<12)
        public var conf_upgate: CONF_UPGATE

        /// This is the enable bit for slave to send data automatically
        @ReadWrite(bits: 12..<13)
        public var slv_tx_auto_start_en: SLV_TX_AUTO_START_EN

        /// This is the enable bit to check if the r/w bit of 10bit addressing consists with I2C protocol
        @ReadWrite(bits: 13..<14)
        public var addr_10bit_rw_check_en: ADDR_10BIT_RW_CHECK_EN

        /// This is the enable bit to support the 7bit general call function.
        @ReadWrite(bits: 14..<15)
        public var addr_broadcasting_en: ADDR_BROADCASTING_EN
    }

    /// Describe I2C work status.
    @Register(bitWidth: 32)
    public struct SR {
        /// The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
        @ReadOnly(bits: 0..<1)
        public var resp_rec: RESP_REC

        /// When in slave mode, 1: master reads from slave, 0: master writes to slave.
        @ReadOnly(bits: 1..<2)
        public var slave_rw: SLAVE_RW

        /// When the I2C controller loses control of SCL line, this register changes to 1.
        @ReadOnly(bits: 3..<4)
        public var arb_lost: ARB_LOST

        /// 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
        @ReadOnly(bits: 4..<5)
        public var bus_busy: BUS_BUSY

        /// equal to the address of the slave, then this bit will be of high level.
        @ReadOnly(bits: 5..<6)
        public var slave_addressed: SLAVE_ADDRESSED

        /// This field represents the amount of data needed to be sent.
        @ReadOnly(bits: 8..<14)
        public var rxfifo_cnt: RXFIFO_CNT

        /// The cause of stretching SCL low in slave mode. 0: stretching SCL low at the beginning of I2C read data state. 1: stretching SCL low when I2C Tx FIFO is empty in slave mode. 2: stretching SCL low when I2C Rx FIFO is full in slave mode.
        @ReadOnly(bits: 14..<16)
        public var stretch_cause: STRETCH_CAUSE

        /// This field stores the amount of received data in RAM.
        @ReadOnly(bits: 18..<24)
        public var txfifo_cnt: TXFIFO_CNT

        /// 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
        @ReadOnly(bits: 24..<27)
        public var scl_main_state_last: SCL_MAIN_STATE_LAST

        /// 0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
        @ReadOnly(bits: 28..<31)
        public var scl_state_last: SCL_STATE_LAST
    }

    /// Setting time out control for receiving data.
    @Register(bitWidth: 32)
    public struct TO {
        /// clock cycles.
        @ReadWrite(bits: 0..<5)
        public var time_out_value: TIME_OUT_VALUE

        /// This is the enable bit for time out control.
        @ReadWrite(bits: 5..<6)
        public var time_out_en: TIME_OUT_EN
    }

    /// Local slave address setting
    @Register(bitWidth: 32)
    public struct SLAVE_ADDR {
        /// When configured as an I2C Slave, this field is used to configure the slave address.
        @ReadWrite(bits: 0..<15)
        public var slave_addr_field: SLAVE_ADDR_FIELD

        /// This field is used to enable the slave 10-bit addressing mode in master mode.
        @ReadWrite(bits: 31..<32)
        public var addr_10bit_en: ADDR_10BIT_EN
    }

    /// FIFO status register.
    @Register(bitWidth: 32)
    public struct FIFO_ST {
        /// This is the offset address of the APB reading from rxfifo
        @ReadOnly(bits: 0..<5)
        public var rxfifo_raddr: RXFIFO_RADDR

        /// This is the offset address of i2c module receiving data and writing to rxfifo.
        @ReadOnly(bits: 5..<10)
        public var rxfifo_waddr: RXFIFO_WADDR

        /// This is the offset address of i2c module reading from txfifo.
        @ReadOnly(bits: 10..<15)
        public var txfifo_raddr: TXFIFO_RADDR

        /// This is the offset address of APB bus writing to txfifo.
        @ReadOnly(bits: 15..<20)
        public var txfifo_waddr: TXFIFO_WADDR

        /// The received data in I2C slave mode.
        @ReadOnly(bits: 22..<30)
        public var slave_rw_point: SLAVE_RW_POINT
    }

    /// FIFO configuration register.
    @Register(bitWidth: 32)
    public struct FIFO_CONF {
        /// The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[4:0], reg_rxfifo_wm_int_raw bit will be valid.
        @ReadWrite(bits: 0..<5)
        public var rxfifo_wm_thrhd: RXFIFO_WM_THRHD

        /// The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[4:0], reg_txfifo_wm_int_raw bit will be valid.
        @ReadWrite(bits: 5..<10)
        public var txfifo_wm_thrhd: TXFIFO_WM_THRHD

        /// Set this bit to enable APB nonfifo access.
        @ReadWrite(bits: 10..<11)
        public var nonfifo_en: NONFIFO_EN

        /// When this bit is set to 1, the byte received after the I2C address byte represents the offset address in the I2C Slave RAM.
        @ReadWrite(bits: 11..<12)
        public var fifo_addr_cfg_en: FIFO_ADDR_CFG_EN

        /// Set this bit to reset rx-fifo.
        @ReadWrite(bits: 12..<13)
        public var rx_fifo_rst: RX_FIFO_RST

        /// Set this bit to reset tx-fifo.
        @ReadWrite(bits: 13..<14)
        public var tx_fifo_rst: TX_FIFO_RST

        /// The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
        @ReadWrite(bits: 14..<15)
        public var fifo_prt_en: FIFO_PRT_EN
    }

    /// Rx FIFO read data.
    @Register(bitWidth: 32)
    public struct DATA {
        /// The value of rx FIFO read data.
        @ReadOnly(bits: 0..<8)
        public var fifo_rdata: FIFO_RDATA
    }

    /// Raw interrupt status
    @Register(bitWidth: 32)
    public struct INT_RAW {
        /// The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var rxfifo_wm_int_raw: RXFIFO_WM_INT_RAW

        /// The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var txfifo_wm_int_raw: TXFIFO_WM_INT_RAW

        /// The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 2..<3)
        public var rxfifo_ovf_int_raw: RXFIFO_OVF_INT_RAW

        /// The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 3..<4)
        public var end_detect_int_raw: END_DETECT_INT_RAW

        /// The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 4..<5)
        public var byte_trans_done_int_raw: BYTE_TRANS_DONE_INT_RAW

        /// The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        @ReadOnly(bits: 5..<6)
        public var arbitration_lost_int_raw: ARBITRATION_LOST_INT_RAW

        /// The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 6..<7)
        public var mst_txfifo_udf_int_raw: MST_TXFIFO_UDF_INT_RAW

        /// The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 7..<8)
        public var trans_complete_int_raw: TRANS_COMPLETE_INT_RAW

        /// The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        @ReadOnly(bits: 8..<9)
        public var time_out_int_raw: TIME_OUT_INT_RAW

        /// The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        @ReadOnly(bits: 9..<10)
        public var trans_start_int_raw: TRANS_START_INT_RAW

        /// The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 10..<11)
        public var nack_int_raw: NACK_INT_RAW

        /// The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 11..<12)
        public var txfifo_ovf_int_raw: TXFIFO_OVF_INT_RAW

        /// The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        @ReadOnly(bits: 12..<13)
        public var rxfifo_udf_int_raw: RXFIFO_UDF_INT_RAW

        /// The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        @ReadOnly(bits: 13..<14)
        public var scl_st_to_int_raw: SCL_ST_TO_INT_RAW

        /// The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        @ReadOnly(bits: 14..<15)
        public var scl_main_st_to_int_raw: SCL_MAIN_ST_TO_INT_RAW

        /// The raw interrupt bit for I2C_DET_START_INT interrupt.
        @ReadOnly(bits: 15..<16)
        public var det_start_int_raw: DET_START_INT_RAW

        /// The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 16..<17)
        public var slave_stretch_int_raw: SLAVE_STRETCH_INT_RAW

        /// The raw interrupt bit for I2C_GENARAL_CALL_INT interrupt.
        @ReadOnly(bits: 17..<18)
        public var general_call_int_raw: GENERAL_CALL_INT_RAW

        /// The raw interrupt bit for I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
        @ReadOnly(bits: 18..<19)
        public var slave_addr_unmatch_int_raw: SLAVE_ADDR_UNMATCH_INT_RAW
    }

    /// Interrupt clear bits
    @Register(bitWidth: 32)
    public struct INT_CLR {
        /// Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
        @WriteOnly(bits: 0..<1)
        public var rxfifo_wm_int_clr: RXFIFO_WM_INT_CLR

        /// Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
        @WriteOnly(bits: 1..<2)
        public var txfifo_wm_int_clr: TXFIFO_WM_INT_CLR

        /// Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
        @WriteOnly(bits: 2..<3)
        public var rxfifo_ovf_int_clr: RXFIFO_OVF_INT_CLR

        /// Set this bit to clear the I2C_END_DETECT_INT interrupt.
        @WriteOnly(bits: 3..<4)
        public var end_detect_int_clr: END_DETECT_INT_CLR

        /// Set this bit to clear the I2C_END_DETECT_INT interrupt.
        @WriteOnly(bits: 4..<5)
        public var byte_trans_done_int_clr: BYTE_TRANS_DONE_INT_CLR

        /// Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
        @WriteOnly(bits: 5..<6)
        public var arbitration_lost_int_clr: ARBITRATION_LOST_INT_CLR

        /// Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
        @WriteOnly(bits: 6..<7)
        public var mst_txfifo_udf_int_clr: MST_TXFIFO_UDF_INT_CLR

        /// Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
        @WriteOnly(bits: 7..<8)
        public var trans_complete_int_clr: TRANS_COMPLETE_INT_CLR

        /// Set this bit to clear the I2C_TIME_OUT_INT interrupt.
        @WriteOnly(bits: 8..<9)
        public var time_out_int_clr: TIME_OUT_INT_CLR

        /// Set this bit to clear the I2C_TRANS_START_INT interrupt.
        @WriteOnly(bits: 9..<10)
        public var trans_start_int_clr: TRANS_START_INT_CLR

        /// Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        @WriteOnly(bits: 10..<11)
        public var nack_int_clr: NACK_INT_CLR

        /// Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
        @WriteOnly(bits: 11..<12)
        public var txfifo_ovf_int_clr: TXFIFO_OVF_INT_CLR

        /// Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.
        @WriteOnly(bits: 12..<13)
        public var rxfifo_udf_int_clr: RXFIFO_UDF_INT_CLR

        /// Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
        @WriteOnly(bits: 13..<14)
        public var scl_st_to_int_clr: SCL_ST_TO_INT_CLR

        /// Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
        @WriteOnly(bits: 14..<15)
        public var scl_main_st_to_int_clr: SCL_MAIN_ST_TO_INT_CLR

        /// Set this bit to clear I2C_DET_START_INT interrupt.
        @WriteOnly(bits: 15..<16)
        public var det_start_int_clr: DET_START_INT_CLR

        /// Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        @WriteOnly(bits: 16..<17)
        public var slave_stretch_int_clr: SLAVE_STRETCH_INT_CLR

        /// Set this bit to clear I2C_GENARAL_CALL_INT interrupt.
        @WriteOnly(bits: 17..<18)
        public var general_call_int_clr: GENERAL_CALL_INT_CLR

        /// Set this bit to clear I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
        @WriteOnly(bits: 18..<19)
        public var slave_addr_unmatch_int_clr: SLAVE_ADDR_UNMATCH_INT_CLR
    }

    /// Interrupt enable bits
    @Register(bitWidth: 32)
    public struct INT_ENA {
        /// The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
        @ReadWrite(bits: 0..<1)
        public var rxfifo_wm_int_ena: RXFIFO_WM_INT_ENA

        /// The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
        @ReadWrite(bits: 1..<2)
        public var txfifo_wm_int_ena: TXFIFO_WM_INT_ENA

        /// The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
        @ReadWrite(bits: 2..<3)
        public var rxfifo_ovf_int_ena: RXFIFO_OVF_INT_ENA

        /// The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        @ReadWrite(bits: 3..<4)
        public var end_detect_int_ena: END_DETECT_INT_ENA

        /// The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        @ReadWrite(bits: 4..<5)
        public var byte_trans_done_int_ena: BYTE_TRANS_DONE_INT_ENA

        /// The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
        @ReadWrite(bits: 5..<6)
        public var arbitration_lost_int_ena: ARBITRATION_LOST_INT_ENA

        /// The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
        @ReadWrite(bits: 6..<7)
        public var mst_txfifo_udf_int_ena: MST_TXFIFO_UDF_INT_ENA

        /// The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
        @ReadWrite(bits: 7..<8)
        public var trans_complete_int_ena: TRANS_COMPLETE_INT_ENA

        /// The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
        @ReadWrite(bits: 8..<9)
        public var time_out_int_ena: TIME_OUT_INT_ENA

        /// The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
        @ReadWrite(bits: 9..<10)
        public var trans_start_int_ena: TRANS_START_INT_ENA

        /// The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadWrite(bits: 10..<11)
        public var nack_int_ena: NACK_INT_ENA

        /// The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
        @ReadWrite(bits: 11..<12)
        public var txfifo_ovf_int_ena: TXFIFO_OVF_INT_ENA

        /// The interrupt enable bit for I2C_RXFIFO_UDF_INT interrupt.
        @ReadWrite(bits: 12..<13)
        public var rxfifo_udf_int_ena: RXFIFO_UDF_INT_ENA

        /// The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
        @ReadWrite(bits: 13..<14)
        public var scl_st_to_int_ena: SCL_ST_TO_INT_ENA

        /// The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        @ReadWrite(bits: 14..<15)
        public var scl_main_st_to_int_ena: SCL_MAIN_ST_TO_INT_ENA

        /// The interrupt enable bit for I2C_DET_START_INT interrupt.
        @ReadWrite(bits: 15..<16)
        public var det_start_int_ena: DET_START_INT_ENA

        /// The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadWrite(bits: 16..<17)
        public var slave_stretch_int_ena: SLAVE_STRETCH_INT_ENA

        /// The interrupt enable bit for I2C_GENARAL_CALL_INT interrupt.
        @ReadWrite(bits: 17..<18)
        public var general_call_int_ena: GENERAL_CALL_INT_ENA

        /// The interrupt enable bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
        @ReadWrite(bits: 18..<19)
        public var slave_addr_unmatch_int_ena: SLAVE_ADDR_UNMATCH_INT_ENA
    }

    /// Status of captured I2C communication events
    @Register(bitWidth: 32)
    public struct INT_STATUS {
        /// The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var rxfifo_wm_int_st: RXFIFO_WM_INT_ST

        /// The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var txfifo_wm_int_st: TXFIFO_WM_INT_ST

        /// The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 2..<3)
        public var rxfifo_ovf_int_st: RXFIFO_OVF_INT_ST

        /// The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 3..<4)
        public var end_detect_int_st: END_DETECT_INT_ST

        /// The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 4..<5)
        public var byte_trans_done_int_st: BYTE_TRANS_DONE_INT_ST

        /// The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
        @ReadOnly(bits: 5..<6)
        public var arbitration_lost_int_st: ARBITRATION_LOST_INT_ST

        /// The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 6..<7)
        public var mst_txfifo_udf_int_st: MST_TXFIFO_UDF_INT_ST

        /// The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 7..<8)
        public var trans_complete_int_st: TRANS_COMPLETE_INT_ST

        /// The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
        @ReadOnly(bits: 8..<9)
        public var time_out_int_st: TIME_OUT_INT_ST

        /// The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
        @ReadOnly(bits: 9..<10)
        public var trans_start_int_st: TRANS_START_INT_ST

        /// The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 10..<11)
        public var nack_int_st: NACK_INT_ST

        /// The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 11..<12)
        public var txfifo_ovf_int_st: TXFIFO_OVF_INT_ST

        /// The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.
        @ReadOnly(bits: 12..<13)
        public var rxfifo_udf_int_st: RXFIFO_UDF_INT_ST

        /// The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
        @ReadOnly(bits: 13..<14)
        public var scl_st_to_int_st: SCL_ST_TO_INT_ST

        /// The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        @ReadOnly(bits: 14..<15)
        public var scl_main_st_to_int_st: SCL_MAIN_ST_TO_INT_ST

        /// The masked interrupt status bit for I2C_DET_START_INT interrupt.
        @ReadOnly(bits: 15..<16)
        public var det_start_int_st: DET_START_INT_ST

        /// The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 16..<17)
        public var slave_stretch_int_st: SLAVE_STRETCH_INT_ST

        /// The masked interrupt status bit for I2C_GENARAL_CALL_INT interrupt.
        @ReadOnly(bits: 17..<18)
        public var general_call_int_st: GENERAL_CALL_INT_ST

        /// The masked interrupt status bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
        @ReadOnly(bits: 18..<19)
        public var slave_addr_unmatch_int_st: SLAVE_ADDR_UNMATCH_INT_ST
    }

    /// Configures the hold time after a negative SCL edge.
    @Register(bitWidth: 32)
    public struct SDA_HOLD {
        /// edge of SCL, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// Configures the sample time after a positive SCL edge.
    @Register(bitWidth: 32)
    public struct SDA_SAMPLE {
        /// This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// Configures the high level width of SCL
    @Register(bitWidth: 32)
    public struct SCL_HIGH_PERIOD {
        /// This register is used to configure for how long SCL remains high in master mode, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var scl_high_period_field: SCL_HIGH_PERIOD_FIELD

        /// This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
        @ReadWrite(bits: 9..<16)
        public var scl_wait_high_period: SCL_WAIT_HIGH_PERIOD
    }

    /// Configures the delay between the SDA and SCL negative edge for a start condition
    @Register(bitWidth: 32)
    public struct SCL_START_HOLD {
        /// of SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// edge of SCL and the negative edge of SDA
    @Register(bitWidth: 32)
    public struct SCL_RSTART_SETUP {
        /// edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// edge for a stop condition
    @Register(bitWidth: 32)
    public struct SCL_STOP_HOLD {
        /// in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// SCL positive edge for a stop condition
    @Register(bitWidth: 32)
    public struct SCL_STOP_SETUP {
        /// of SCL and the positive edge of SDA, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// SCL and SDA filter configuration register
    @Register(bitWidth: 32)
    public struct FILTER_CFG {
        /// in I2C module clock cycles, the I2C controller will ignore that pulse.
        @ReadWrite(bits: 0..<4)
        public var scl_filter_thres: SCL_FILTER_THRES

        /// in I2C module clock cycles, the I2C controller will ignore that pulse.
        @ReadWrite(bits: 4..<8)
        public var sda_filter_thres: SDA_FILTER_THRES

        /// This is the filter enable bit for SCL.
        @ReadWrite(bits: 8..<9)
        public var scl_filter_en: SCL_FILTER_EN

        /// This is the filter enable bit for SDA.
        @ReadWrite(bits: 9..<10)
        public var sda_filter_en: SDA_FILTER_EN
    }

    /// I2C CLK configuration register
    @Register(bitWidth: 32)
    public struct CLK_CONF {
        /// the integral part of the fractional divisor for i2c module
        @ReadWrite(bits: 0..<8)
        public var sclk_div_num: SCLK_DIV_NUM

        /// the numerator of the fractional part of the fractional divisor for i2c module
        @ReadWrite(bits: 8..<14)
        public var sclk_div_a: SCLK_DIV_A

        /// the denominator of the fractional part of the fractional divisor for i2c module
        @ReadWrite(bits: 14..<20)
        public var sclk_div_b: SCLK_DIV_B

        /// The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
        @ReadWrite(bits: 20..<21)
        public var sclk_sel: SCLK_SEL

        /// The clock switch for i2c module
        @ReadWrite(bits: 21..<22)
        public var sclk_active: SCLK_ACTIVE
    }

    /// I2C command register 0
    @Register(bitWidth: 32)
    public struct COMD0 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command0: COMMAND0

        /// level.
        @ReadWrite(bits: 31..<32)
        public var command0_done: COMMAND0_DONE
    }

    /// I2C command register 1
    @Register(bitWidth: 32)
    public struct COMD1 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command1: COMMAND1

        /// level.
        @ReadWrite(bits: 31..<32)
        public var command1_done: COMMAND1_DONE
    }

    /// I2C command register 2
    @Register(bitWidth: 32)
    public struct COMD2 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command2: COMMAND2

        /// Level.
        @ReadWrite(bits: 31..<32)
        public var command2_done: COMMAND2_DONE
    }

    /// I2C command register 3
    @Register(bitWidth: 32)
    public struct COMD3 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command3: COMMAND3

        /// level.
        @ReadWrite(bits: 31..<32)
        public var command3_done: COMMAND3_DONE
    }

    /// I2C command register 4
    @Register(bitWidth: 32)
    public struct COMD4 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command4: COMMAND4

        /// level.
        @ReadWrite(bits: 31..<32)
        public var command4_done: COMMAND4_DONE
    }

    /// I2C command register 5
    @Register(bitWidth: 32)
    public struct COMD5 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command5: COMMAND5

        /// When command 5 is done in I2C Master mode, this bit changes to high level.
        @ReadWrite(bits: 31..<32)
        public var command5_done: COMMAND5_DONE
    }

    /// I2C command register 6
    @Register(bitWidth: 32)
    public struct COMD6 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command6: COMMAND6

        /// When command 6 is done in I2C Master mode, this bit changes to high level.
        @ReadWrite(bits: 31..<32)
        public var command6_done: COMMAND6_DONE
    }

    /// I2C command register 7
    @Register(bitWidth: 32)
    public struct COMD7 {
        /// Information.
        @ReadWrite(bits: 0..<14)
        public var command7: COMMAND7

        /// When command 7 is done in I2C Master mode, this bit changes to high level.
        @ReadWrite(bits: 31..<32)
        public var command7_done: COMMAND7_DONE
    }

    /// SCL status time out register
    @Register(bitWidth: 32)
    public struct SCL_ST_TIME_OUT {
        /// The threshold value of SCL_FSM state unchanged period. It should be o more than 23
        @ReadWrite(bits: 0..<5)
        public var scl_st_to_i2c: SCL_ST_TO_I2C
    }

    /// SCL main status time out register
    @Register(bitWidth: 32)
    public struct SCL_MAIN_ST_TIME_OUT {
        /// The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
        @ReadWrite(bits: 0..<5)
        public var scl_main_st_to_i2c: SCL_MAIN_ST_TO_I2C
    }

    /// Power configuration register
    @Register(bitWidth: 32)
    public struct SCL_SP_CONF {
        /// When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
        @ReadWrite(bits: 0..<1)
        public var scl_rst_slv_en: SCL_RST_SLV_EN

        /// Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
        @ReadWrite(bits: 1..<6)
        public var scl_rst_slv_num: SCL_RST_SLV_NUM

        /// The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
        @ReadWrite(bits: 6..<7)
        public var scl_pd_en: SCL_PD_EN

        /// The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
        @ReadWrite(bits: 7..<8)
        public var sda_pd_en: SDA_PD_EN
    }

    /// Set SCL stretch of I2C slave
    @Register(bitWidth: 32)
    public struct SCL_STRETCH_CONF {
        /// Configure the period of I2C slave stretching SCL line.
        @ReadWrite(bits: 0..<10)
        public var stretch_protect_num: STRETCH_PROTECT_NUM

        /// The enable bit for slave SCL stretch function. 1: Enable. 0: Disable. The SCL output line will be stretched low when reg_slave_scl_stretch_en is 1 and stretch event happens. The stretch cause can be seen in reg_stretch_cause.
        @ReadWrite(bits: 10..<11)
        public var slave_scl_stretch_en: SLAVE_SCL_STRETCH_EN

        /// Set this bit to clear the I2C slave SCL stretch function.
        @WriteOnly(bits: 11..<12)
        public var slave_scl_stretch_clr: SLAVE_SCL_STRETCH_CLR

        /// The enable bit for slave to control ACK level function.
        @ReadWrite(bits: 12..<13)
        public var slave_byte_ack_ctl_en: SLAVE_BYTE_ACK_CTL_EN

        /// Set the ACK level when slave controlling ACK level function enables.
        @ReadWrite(bits: 13..<14)
        public var slave_byte_ack_lvl: SLAVE_BYTE_ACK_LVL
    }

    /// Version register
    @Register(bitWidth: 32)
    public struct DATE {
        /// This is the the version register.
        @ReadWrite(bits: 0..<32)
        public var date_field: DATE_FIELD
    }

    /// I2C TXFIFO base address register
    @Register(bitWidth: 32)
    public struct TXFIFO_START_ADDR {
        /// This is the I2C txfifo first address.
        @ReadOnly(bits: 0..<32)
        public var txfifo_start_addr_field: TXFIFO_START_ADDR_FIELD
    }

    /// I2C RXFIFO base address register
    @Register(bitWidth: 32)
    public struct RXFIFO_START_ADDR {
        /// This is the I2C rxfifo first address.
        @ReadOnly(bits: 0..<32)
        public var rxfifo_start_addr_field: RXFIFO_START_ADDR_FIELD
    }
}
