// Generated by svd2swift.

import MMIO

/// I2C (Inter-Integrated Circuit) Controller 0
@RegisterBlock
public struct I2C0 {
    /// Clock
    @RegisterBlock(offset: 0x0)
    public var scl_low_period: Register<SCL_LOW_PERIOD>

    /// Transmission setting
    @RegisterBlock(offset: 0x4)
    public var ctr: Register<CTR>

    /// Describe I2C work status.
    @RegisterBlock(offset: 0x8)
    public var sr: Register<SR>

    /// Setting time out control for receiving data.
    @RegisterBlock(offset: 0xc)
    public var to: Register<TO>

    /// Local slave address setting
    @RegisterBlock(offset: 0x10)
    public var slave_addr: Register<SLAVE_ADDR>

    /// FIFO status register.
    @RegisterBlock(offset: 0x14)
    public var fifo_st: Register<FIFO_ST>

    /// FIFO configuration register.
    @RegisterBlock(offset: 0x18)
    public var fifo_conf: Register<FIFO_CONF>

    /// Rx FIFO read data.
    @RegisterBlock(offset: 0x1c)
    public var data: Register<DATA>

    /// Raw interrupt status
    @RegisterBlock(offset: 0x20)
    public var int_raw: Register<INT_RAW>

    /// Interrupt clear bits
    @RegisterBlock(offset: 0x24)
    public var int_clr: Register<INT_CLR>

    /// Interrupt enable bits
    @RegisterBlock(offset: 0x28)
    public var int_ena: Register<INT_ENA>

    /// Status of captured I2C communication events
    @RegisterBlock(offset: 0x2c)
    public var int_st: Register<INT_ST>

    /// Configures the hold time after a negative SCL edge.
    @RegisterBlock(offset: 0x30)
    public var sda_hold: Register<SDA_HOLD>

    /// Configures the sample time after a positive SCL edge.
    @RegisterBlock(offset: 0x34)
    public var sda_sample: Register<SDA_SAMPLE>

    /// Configures the high level width of SCL
    @RegisterBlock(offset: 0x38)
    public var scl_high_period: Register<SCL_HIGH_PERIOD>

    /// Configures the delay between the SDA and SCL negative edge for a start condition
    @RegisterBlock(offset: 0x40)
    public var scl_start_hold: Register<SCL_START_HOLD>

    /// edge of SCL and the negative edge of SDA
    @RegisterBlock(offset: 0x44)
    public var scl_rstart_setup: Register<SCL_RSTART_SETUP>

    /// edge for a stop condition
    @RegisterBlock(offset: 0x48)
    public var scl_stop_hold: Register<SCL_STOP_HOLD>

    /// SCL positive edge for a stop condition
    @RegisterBlock(offset: 0x4c)
    public var scl_stop_setup: Register<SCL_STOP_SETUP>

    /// SCL and SDA filter configuration register
    @RegisterBlock(offset: 0x50)
    public var filter_cfg: Register<FILTER_CFG>

    /// I2C CLK configuration register
    @RegisterBlock(offset: 0x54)
    public var clk_conf: Register<CLK_CONF>

    /// I2C command register %s
    @RegisterBlock(offset: 0x58, stride: 0x4, count: 8)
    public var comd: RegisterArray<COMD>

    /// SCL status time out register
    @RegisterBlock(offset: 0x78)
    public var scl_st_time_out: Register<SCL_ST_TIME_OUT>

    /// SCL main status time out register
    @RegisterBlock(offset: 0x7c)
    public var scl_main_st_time_out: Register<SCL_MAIN_ST_TIME_OUT>

    /// Power configuration register
    @RegisterBlock(offset: 0x80)
    public var scl_sp_conf: Register<SCL_SP_CONF>

    /// Set SCL stretch of I2C slave
    @RegisterBlock(offset: 0x84)
    public var scl_stretch_conf: Register<SCL_STRETCH_CONF>

    /// Version register
    @RegisterBlock(offset: 0xf8)
    public var date: Register<DATE>

    /// I2C TXFIFO base address register
    @RegisterBlock(offset: 0x100)
    public var txfifo_start_addr: Register<TXFIFO_START_ADDR>

    /// I2C RXFIFO base address register
    @RegisterBlock(offset: 0x180)
    public var rxfifo_start_addr: Register<RXFIFO_START_ADDR>
}

extension I2C0 {
    /// Clock
    @Register(bitWidth: 32)
    public struct SCL_LOW_PERIOD {
        /// This register is used to configure for how long SCL remains low in master mode, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var scl_low_period_field: SCL_LOW_PERIOD_FIELD
    }

    /// Transmission setting
    @Register(bitWidth: 32)
    public struct CTR {
        /// 1: direct output, 0: open drain output.
        @ReadWrite(bits: 0..<1)
        public var sda_force_out: SDA_FORCE_OUT

        /// 1: direct output, 0: open drain output.
        @ReadWrite(bits: 1..<2)
        public var scl_force_out: SCL_FORCE_OUT

        /// 0: sample SDA data on the SCL high level.
        @ReadWrite(bits: 2..<3)
        public var sample_scl_level: SAMPLE_SCL_LEVEL

        /// This register is used to configure the ACK value that need to sent by master when the rx_fifo_cnt has reached the threshold.
        @ReadWrite(bits: 3..<4)
        public var rx_full_ack_level: RX_FULL_ACK_LEVEL

        /// module as an I2C Slave.
        @ReadWrite(bits: 4..<5)
        public var ms_mode: MS_MODE

        /// Set this bit to start sending the data in txfifo.
        @WriteOnly(bits: 5..<6)
        public var trans_start: TRANS_START

        /// 0: send data from the most significant bit.
        @ReadWrite(bits: 6..<7)
        public var tx_lsb_first: TX_LSB_FIRST

        /// 0: receive data from the most significant bit.
        @ReadWrite(bits: 7..<8)
        public var rx_lsb_first: RX_LSB_FIRST

        /// Reserved
        @ReadWrite(bits: 8..<9)
        public var clk_en: CLK_EN

        /// This is the enable bit for arbitration_lost.
        @ReadWrite(bits: 9..<10)
        public var arbitration_en: ARBITRATION_EN

        /// This register is used to reset the scl FMS.
        @WriteOnly(bits: 10..<11)
        public var fsm_rst: FSM_RST

        /// synchronization bit
        @WriteOnly(bits: 11..<12)
        public var conf_upgate: CONF_UPGATE

        /// This is the enable bit for slave to send data automatically
        @ReadWrite(bits: 12..<13)
        public var slv_tx_auto_start_en: SLV_TX_AUTO_START_EN

        /// This is the enable bit to check if the r/w bit of 10bit addressing consists with I2C protocol
        @ReadWrite(bits: 13..<14)
        public var addr_10bit_rw_check_en: ADDR_10BIT_RW_CHECK_EN

        /// This is the enable bit to support the 7bit general call function.
        @ReadWrite(bits: 14..<15)
        public var addr_broadcasting_en: ADDR_BROADCASTING_EN
    }

    /// Describe I2C work status.
    @Register(bitWidth: 32)
    public struct SR {
        /// The received ACK value in master mode or slave mode. 0: ACK, 1: NACK.
        @ReadOnly(bits: 0..<1)
        public var resp_rec: RESP_REC

        /// When in slave mode, 1: master reads from slave, 0: master writes to slave.
        @ReadOnly(bits: 1..<2)
        public var slave_rw: SLAVE_RW

        /// When the I2C controller loses control of SCL line, this register changes to 1.
        @ReadOnly(bits: 3..<4)
        public var arb_lost: ARB_LOST

        /// 1: the I2C bus is busy transferring data, 0: the I2C bus is in idle state.
        @ReadOnly(bits: 4..<5)
        public var bus_busy: BUS_BUSY

        /// equal to the address of the slave, then this bit will be of high level.
        @ReadOnly(bits: 5..<6)
        public var slave_addressed: SLAVE_ADDRESSED

        /// This field represents the amount of data needed to be sent.
        @ReadOnly(bits: 8..<14)
        public var rxfifo_cnt: RXFIFO_CNT

        /// The cause of stretching SCL low in slave mode. 0: stretching SCL low at the beginning of I2C read data state. 1: stretching SCL low when I2C Tx FIFO is empty in slave mode. 2: stretching SCL low when I2C Rx FIFO is full in slave mode.
        @ReadOnly(bits: 14..<16)
        public var stretch_cause: STRETCH_CAUSE

        /// This field stores the amount of received data in RAM.
        @ReadOnly(bits: 18..<24)
        public var txfifo_cnt: TXFIFO_CNT

        /// 0: Idle, 1: Address shift, 2: ACK address, 3: Rx data, 4: Tx data, 5: Send ACK, 6: Wait ACK
        @ReadOnly(bits: 24..<27)
        public var scl_main_state_last: SCL_MAIN_STATE_LAST

        /// 0: Idle, 1: Start, 2: Negative edge, 3: Low, 4: Positive edge, 5: High, 6: Stop
        @ReadOnly(bits: 28..<31)
        public var scl_state_last: SCL_STATE_LAST
    }

    /// Setting time out control for receiving data.
    @Register(bitWidth: 32)
    public struct TO {
        /// clock cycles.
        @ReadWrite(bits: 0..<5)
        public var time_out_value: TIME_OUT_VALUE

        /// This is the enable bit for time out control.
        @ReadWrite(bits: 5..<6)
        public var time_out_en: TIME_OUT_EN
    }

    /// Local slave address setting
    @Register(bitWidth: 32)
    public struct SLAVE_ADDR {
        /// When configured as an I2C Slave, this field is used to configure the slave address.
        @ReadWrite(bits: 0..<15)
        public var slave_addr_field: SLAVE_ADDR_FIELD

        /// This field is used to enable the slave 10-bit addressing mode in master mode.
        @ReadWrite(bits: 31..<32)
        public var addr_10bit_en: ADDR_10BIT_EN
    }

    /// FIFO status register.
    @Register(bitWidth: 32)
    public struct FIFO_ST {
        /// This is the offset address of the APB reading from rxfifo
        @ReadOnly(bits: 0..<5)
        public var rxfifo_raddr: RXFIFO_RADDR

        /// This is the offset address of i2c module receiving data and writing to rxfifo.
        @ReadOnly(bits: 5..<10)
        public var rxfifo_waddr: RXFIFO_WADDR

        /// This is the offset address of i2c module reading from txfifo.
        @ReadOnly(bits: 10..<15)
        public var txfifo_raddr: TXFIFO_RADDR

        /// This is the offset address of APB bus writing to txfifo.
        @ReadOnly(bits: 15..<20)
        public var txfifo_waddr: TXFIFO_WADDR

        /// The received data in I2C slave mode.
        @ReadOnly(bits: 22..<30)
        public var slave_rw_point: SLAVE_RW_POINT
    }

    /// FIFO configuration register.
    @Register(bitWidth: 32)
    public struct FIFO_CONF {
        /// The water mark threshold of rx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger than reg_rxfifo_wm_thrhd[4:0], reg_rxfifo_wm_int_raw bit will be valid.
        @ReadWrite(bits: 0..<5)
        public var rxfifo_wm_thrhd: RXFIFO_WM_THRHD

        /// The water mark threshold of tx FIFO in nonfifo access mode. When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller than reg_txfifo_wm_thrhd[4:0], reg_txfifo_wm_int_raw bit will be valid.
        @ReadWrite(bits: 5..<10)
        public var txfifo_wm_thrhd: TXFIFO_WM_THRHD

        /// Set this bit to enable APB nonfifo access.
        @ReadWrite(bits: 10..<11)
        public var nonfifo_en: NONFIFO_EN

        /// When this bit is set to 1, the byte received after the I2C address byte represents the offset address in the I2C Slave RAM.
        @ReadWrite(bits: 11..<12)
        public var fifo_addr_cfg_en: FIFO_ADDR_CFG_EN

        /// Set this bit to reset rx-fifo.
        @ReadWrite(bits: 12..<13)
        public var rx_fifo_rst: RX_FIFO_RST

        /// Set this bit to reset tx-fifo.
        @ReadWrite(bits: 13..<14)
        public var tx_fifo_rst: TX_FIFO_RST

        /// The control enable bit of FIFO pointer in non-fifo access mode. This bit controls the valid bits and the interrupts of tx/rx_fifo overflow, underflow, full and empty.
        @ReadWrite(bits: 14..<15)
        public var fifo_prt_en: FIFO_PRT_EN
    }

    /// Rx FIFO read data.
    @Register(bitWidth: 32)
    public struct DATA {
        /// The value of rx FIFO read data.
        @ReadWrite(bits: 0..<8)
        public var fifo_rdata: FIFO_RDATA
    }

    /// Raw interrupt status
    @Register(bitWidth: 32)
    public struct INT_RAW {
        /// The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var rxfifo_wm: RXFIFO_WM

        /// The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var txfifo_wm: TXFIFO_WM

        /// The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 2..<3)
        public var rxfifo_ovf: RXFIFO_OVF

        /// The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 3..<4)
        public var end_detect: END_DETECT

        /// The raw interrupt bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 4..<5)
        public var byte_trans_done: BYTE_TRANS_DONE

        /// The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.
        @ReadOnly(bits: 5..<6)
        public var arbitration_lost: ARBITRATION_LOST

        /// The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 6..<7)
        public var mst_txfifo_udf: MST_TXFIFO_UDF

        /// The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 7..<8)
        public var trans_complete: TRANS_COMPLETE

        /// The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.
        @ReadOnly(bits: 8..<9)
        public var time_out: TIME_OUT

        /// The raw interrupt bit for the I2C_TRANS_START_INT interrupt.
        @ReadOnly(bits: 9..<10)
        public var trans_start: TRANS_START

        /// The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 10..<11)
        public var nack: NACK

        /// The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 11..<12)
        public var txfifo_ovf: TXFIFO_OVF

        /// The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.
        @ReadOnly(bits: 12..<13)
        public var rxfifo_udf: RXFIFO_UDF

        /// The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.
        @ReadOnly(bits: 13..<14)
        public var scl_st_to: SCL_ST_TO

        /// The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        @ReadOnly(bits: 14..<15)
        public var scl_main_st_to: SCL_MAIN_ST_TO

        /// The raw interrupt bit for I2C_DET_START_INT interrupt.
        @ReadOnly(bits: 15..<16)
        public var det_start: DET_START

        /// The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 16..<17)
        public var slave_stretch: SLAVE_STRETCH

        /// The raw interrupt bit for I2C_GENARAL_CALL_INT interrupt.
        @ReadOnly(bits: 17..<18)
        public var general_call: GENERAL_CALL

        /// The raw interrupt bit for I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
        @ReadOnly(bits: 18..<19)
        public var slave_addr_unmatch: SLAVE_ADDR_UNMATCH
    }

    /// Interrupt clear bits
    @Register(bitWidth: 32)
    public struct INT_CLR {
        /// Set this bit to clear I2C_RXFIFO_WM_INT interrupt.
        @WriteOnly(bits: 0..<1)
        public var rxfifo_wm: RXFIFO_WM

        /// Set this bit to clear I2C_TXFIFO_WM_INT interrupt.
        @WriteOnly(bits: 1..<2)
        public var txfifo_wm: TXFIFO_WM

        /// Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.
        @WriteOnly(bits: 2..<3)
        public var rxfifo_ovf: RXFIFO_OVF

        /// Set this bit to clear the I2C_END_DETECT_INT interrupt.
        @WriteOnly(bits: 3..<4)
        public var end_detect: END_DETECT

        /// Set this bit to clear the I2C_END_DETECT_INT interrupt.
        @WriteOnly(bits: 4..<5)
        public var byte_trans_done: BYTE_TRANS_DONE

        /// Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.
        @WriteOnly(bits: 5..<6)
        public var arbitration_lost: ARBITRATION_LOST

        /// Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.
        @WriteOnly(bits: 6..<7)
        public var mst_txfifo_udf: MST_TXFIFO_UDF

        /// Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.
        @WriteOnly(bits: 7..<8)
        public var trans_complete: TRANS_COMPLETE

        /// Set this bit to clear the I2C_TIME_OUT_INT interrupt.
        @WriteOnly(bits: 8..<9)
        public var time_out: TIME_OUT

        /// Set this bit to clear the I2C_TRANS_START_INT interrupt.
        @WriteOnly(bits: 9..<10)
        public var trans_start: TRANS_START

        /// Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        @WriteOnly(bits: 10..<11)
        public var nack: NACK

        /// Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.
        @WriteOnly(bits: 11..<12)
        public var txfifo_ovf: TXFIFO_OVF

        /// Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.
        @WriteOnly(bits: 12..<13)
        public var rxfifo_udf: RXFIFO_UDF

        /// Set this bit to clear I2C_SCL_ST_TO_INT interrupt.
        @WriteOnly(bits: 13..<14)
        public var scl_st_to: SCL_ST_TO

        /// Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.
        @WriteOnly(bits: 14..<15)
        public var scl_main_st_to: SCL_MAIN_ST_TO

        /// Set this bit to clear I2C_DET_START_INT interrupt.
        @WriteOnly(bits: 15..<16)
        public var det_start: DET_START

        /// Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.
        @WriteOnly(bits: 16..<17)
        public var slave_stretch: SLAVE_STRETCH

        /// Set this bit to clear I2C_GENARAL_CALL_INT interrupt.
        @WriteOnly(bits: 17..<18)
        public var general_call: GENERAL_CALL

        /// Set this bit to clear I2C_SLAVE_ADDR_UNMATCH_INT_RAW interrupt.
        @WriteOnly(bits: 18..<19)
        public var slave_addr_unmatch: SLAVE_ADDR_UNMATCH
    }

    /// Interrupt enable bits
    @Register(bitWidth: 32)
    public struct INT_ENA {
        /// The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.
        @ReadWrite(bits: 0..<1)
        public var rxfifo_wm: RXFIFO_WM

        /// The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.
        @ReadWrite(bits: 1..<2)
        public var txfifo_wm: TXFIFO_WM

        /// The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.
        @ReadWrite(bits: 2..<3)
        public var rxfifo_ovf: RXFIFO_OVF

        /// The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        @ReadWrite(bits: 3..<4)
        public var end_detect: END_DETECT

        /// The interrupt enable bit for the I2C_END_DETECT_INT interrupt.
        @ReadWrite(bits: 4..<5)
        public var byte_trans_done: BYTE_TRANS_DONE

        /// The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.
        @ReadWrite(bits: 5..<6)
        public var arbitration_lost: ARBITRATION_LOST

        /// The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.
        @ReadWrite(bits: 6..<7)
        public var mst_txfifo_udf: MST_TXFIFO_UDF

        /// The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.
        @ReadWrite(bits: 7..<8)
        public var trans_complete: TRANS_COMPLETE

        /// The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.
        @ReadWrite(bits: 8..<9)
        public var time_out: TIME_OUT

        /// The interrupt enable bit for the I2C_TRANS_START_INT interrupt.
        @ReadWrite(bits: 9..<10)
        public var trans_start: TRANS_START

        /// The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadWrite(bits: 10..<11)
        public var nack: NACK

        /// The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.
        @ReadWrite(bits: 11..<12)
        public var txfifo_ovf: TXFIFO_OVF

        /// The interrupt enable bit for I2C_RXFIFO_UDF_INT interrupt.
        @ReadWrite(bits: 12..<13)
        public var rxfifo_udf: RXFIFO_UDF

        /// The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.
        @ReadWrite(bits: 13..<14)
        public var scl_st_to: SCL_ST_TO

        /// The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        @ReadWrite(bits: 14..<15)
        public var scl_main_st_to: SCL_MAIN_ST_TO

        /// The interrupt enable bit for I2C_DET_START_INT interrupt.
        @ReadWrite(bits: 15..<16)
        public var det_start: DET_START

        /// The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadWrite(bits: 16..<17)
        public var slave_stretch: SLAVE_STRETCH

        /// The interrupt enable bit for I2C_GENARAL_CALL_INT interrupt.
        @ReadWrite(bits: 17..<18)
        public var general_call: GENERAL_CALL

        /// The interrupt enable bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
        @ReadWrite(bits: 18..<19)
        public var slave_addr_unmatch: SLAVE_ADDR_UNMATCH
    }

    /// Status of captured I2C communication events
    @Register(bitWidth: 32)
    public struct INT_ST {
        /// The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var rxfifo_wm: RXFIFO_WM

        /// The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var txfifo_wm: TXFIFO_WM

        /// The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 2..<3)
        public var rxfifo_ovf: RXFIFO_OVF

        /// The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 3..<4)
        public var end_detect: END_DETECT

        /// The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.
        @ReadOnly(bits: 4..<5)
        public var byte_trans_done: BYTE_TRANS_DONE

        /// The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT interrupt.
        @ReadOnly(bits: 5..<6)
        public var arbitration_lost: ARBITRATION_LOST

        /// The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 6..<7)
        public var mst_txfifo_udf: MST_TXFIFO_UDF

        /// The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT interrupt.
        @ReadOnly(bits: 7..<8)
        public var trans_complete: TRANS_COMPLETE

        /// The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.
        @ReadOnly(bits: 8..<9)
        public var time_out: TIME_OUT

        /// The masked interrupt status bit for the I2C_TRANS_START_INT interrupt.
        @ReadOnly(bits: 9..<10)
        public var trans_start: TRANS_START

        /// The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 10..<11)
        public var nack: NACK

        /// The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.
        @ReadOnly(bits: 11..<12)
        public var txfifo_ovf: TXFIFO_OVF

        /// The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.
        @ReadOnly(bits: 12..<13)
        public var rxfifo_udf: RXFIFO_UDF

        /// The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.
        @ReadOnly(bits: 13..<14)
        public var scl_st_to: SCL_ST_TO

        /// The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.
        @ReadOnly(bits: 14..<15)
        public var scl_main_st_to: SCL_MAIN_ST_TO

        /// The masked interrupt status bit for I2C_DET_START_INT interrupt.
        @ReadOnly(bits: 15..<16)
        public var det_start: DET_START

        /// The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.
        @ReadOnly(bits: 16..<17)
        public var slave_stretch: SLAVE_STRETCH

        /// The masked interrupt status bit for I2C_GENARAL_CALL_INT interrupt.
        @ReadOnly(bits: 17..<18)
        public var general_call: GENERAL_CALL

        /// The masked interrupt status bit for I2C_SLAVE_ADDR_UNMATCH_INT interrupt.
        @ReadOnly(bits: 18..<19)
        public var slave_addr_unmatch: SLAVE_ADDR_UNMATCH
    }

    /// Configures the hold time after a negative SCL edge.
    @Register(bitWidth: 32)
    public struct SDA_HOLD {
        /// edge of SCL, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// Configures the sample time after a positive SCL edge.
    @Register(bitWidth: 32)
    public struct SDA_SAMPLE {
        /// This register is used to configure for how long SDA is sampled, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// Configures the high level width of SCL
    @Register(bitWidth: 32)
    public struct SCL_HIGH_PERIOD {
        /// This register is used to configure for how long SCL remains high in master mode, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var scl_high_period_field: SCL_HIGH_PERIOD_FIELD

        /// This register is used to configure for the SCL_FSM's waiting period for SCL high level in master mode, in I2C module clock cycles.
        @ReadWrite(bits: 9..<16)
        public var scl_wait_high_period: SCL_WAIT_HIGH_PERIOD
    }

    /// Configures the delay between the SDA and SCL negative edge for a start condition
    @Register(bitWidth: 32)
    public struct SCL_START_HOLD {
        /// of SDA and the negative edge of SCL for a START condition, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// edge of SCL and the negative edge of SDA
    @Register(bitWidth: 32)
    public struct SCL_RSTART_SETUP {
        /// edge of SCL and the negative edge of SDA for a RESTART condition, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// edge for a stop condition
    @Register(bitWidth: 32)
    public struct SCL_STOP_HOLD {
        /// in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// SCL positive edge for a stop condition
    @Register(bitWidth: 32)
    public struct SCL_STOP_SETUP {
        /// of SCL and the positive edge of SDA, in I2C module clock cycles.
        @ReadWrite(bits: 0..<9)
        public var time: TIME
    }

    /// SCL and SDA filter configuration register
    @Register(bitWidth: 32)
    public struct FILTER_CFG {
        /// in I2C module clock cycles, the I2C controller will ignore that pulse.
        @ReadWrite(bits: 0..<4)
        public var scl_filter_thres: SCL_FILTER_THRES

        /// in I2C module clock cycles, the I2C controller will ignore that pulse.
        @ReadWrite(bits: 4..<8)
        public var sda_filter_thres: SDA_FILTER_THRES

        /// This is the filter enable bit for SCL.
        @ReadWrite(bits: 8..<9)
        public var scl_filter_en: SCL_FILTER_EN

        /// This is the filter enable bit for SDA.
        @ReadWrite(bits: 9..<10)
        public var sda_filter_en: SDA_FILTER_EN
    }

    /// I2C CLK configuration register
    @Register(bitWidth: 32)
    public struct CLK_CONF {
        /// the integral part of the fractional divisor for i2c module
        @ReadWrite(bits: 0..<8)
        public var sclk_div_num: SCLK_DIV_NUM

        /// the numerator of the fractional part of the fractional divisor for i2c module
        @ReadWrite(bits: 8..<14)
        public var sclk_div_a: SCLK_DIV_A

        /// the denominator of the fractional part of the fractional divisor for i2c module
        @ReadWrite(bits: 14..<20)
        public var sclk_div_b: SCLK_DIV_B

        /// The clock selection for i2c module:0-XTAL,1-CLK_8MHz.
        @ReadWrite(bits: 20..<21)
        public var sclk_sel: SCLK_SEL

        /// The clock switch for i2c module
        @ReadWrite(bits: 21..<22)
        public var sclk_active: SCLK_ACTIVE
    }

    /// I2C command register %s
    @Register(bitWidth: 32)
    public struct COMD {
        /// level.
        @ReadWrite(bits: 31..<32)
        public var command_done: COMMAND_DONE

        /// Opcode part of command %s.
        @ReadWrite(bits: 11..<14, as: Opcode.self)
        public var opcode: OPCODE

        /// Acknowledge value for command %s.
        @ReadWrite(bits: 10..<11)
        public var ack_value: ACK_VALUE

        /// Acknowledge expected for command %s.
        @ReadWrite(bits: 9..<10)
        public var ack_exp: ACK_EXP

        /// Acknowledge check enable for command %s.
        @ReadWrite(bits: 8..<9)
        public var ack_check_en: ACK_CHECK_EN

        /// Number of bytes to be sent or received for command %s.
        @ReadWrite(bits: 0..<8)
        public var byte_num: BYTE_NUM
    }

    /// SCL status time out register
    @Register(bitWidth: 32)
    public struct SCL_ST_TIME_OUT {
        /// The threshold value of SCL_FSM state unchanged period. It should be o more than 23
        @ReadWrite(bits: 0..<5)
        public var scl_st_to: SCL_ST_TO
    }

    /// SCL main status time out register
    @Register(bitWidth: 32)
    public struct SCL_MAIN_ST_TIME_OUT {
        /// The threshold value of SCL_MAIN_FSM state unchanged period.nIt should be o more than 23
        @ReadWrite(bits: 0..<5)
        public var scl_main_st_to: SCL_MAIN_ST_TO
    }

    /// Power configuration register
    @Register(bitWidth: 32)
    public struct SCL_SP_CONF {
        /// When I2C master is IDLE, set this bit to send out SCL pulses. The number of pulses equals to reg_scl_rst_slv_num[4:0].
        @ReadWrite(bits: 0..<1)
        public var scl_rst_slv_en: SCL_RST_SLV_EN

        /// Configure the pulses of SCL generated in I2C master mode. Valid when reg_scl_rst_slv_en is 1.
        @ReadWrite(bits: 1..<6)
        public var scl_rst_slv_num: SCL_RST_SLV_NUM

        /// The power down enable bit for the I2C output SCL line. 1: Power down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en to 1 to stretch SCL low.
        @ReadWrite(bits: 6..<7)
        public var scl_pd_en: SCL_PD_EN

        /// The power down enable bit for the I2C output SDA line. 1: Power down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en to 1 to stretch SDA low.
        @ReadWrite(bits: 7..<8)
        public var sda_pd_en: SDA_PD_EN
    }

    /// Set SCL stretch of I2C slave
    @Register(bitWidth: 32)
    public struct SCL_STRETCH_CONF {
        /// Configure the period of I2C slave stretching SCL line.
        @ReadWrite(bits: 0..<10)
        public var stretch_protect_num: STRETCH_PROTECT_NUM

        /// The enable bit for slave SCL stretch function. 1: Enable. 0: Disable. The SCL output line will be stretched low when reg_slave_scl_stretch_en is 1 and stretch event happens. The stretch cause can be seen in reg_stretch_cause.
        @ReadWrite(bits: 10..<11)
        public var slave_scl_stretch_en: SLAVE_SCL_STRETCH_EN

        /// Set this bit to clear the I2C slave SCL stretch function.
        @WriteOnly(bits: 11..<12)
        public var slave_scl_stretch_clr: SLAVE_SCL_STRETCH_CLR

        /// The enable bit for slave to control ACK level function.
        @ReadWrite(bits: 12..<13)
        public var slave_byte_ack_ctl_en: SLAVE_BYTE_ACK_CTL_EN

        /// Set the ACK level when slave controlling ACK level function enables.
        @ReadWrite(bits: 13..<14)
        public var slave_byte_ack_lvl: SLAVE_BYTE_ACK_LVL
    }

    /// Version register
    @Register(bitWidth: 32)
    public struct DATE {
        /// This is the the version register.
        @ReadWrite(bits: 0..<32)
        public var date_field: DATE_FIELD
    }

    /// I2C TXFIFO base address register
    @Register(bitWidth: 32)
    public struct TXFIFO_START_ADDR {
        /// This is the I2C txfifo first address.
        @ReadOnly(bits: 0..<32)
        public var txfifo_start_addr_field: TXFIFO_START_ADDR_FIELD
    }

    /// I2C RXFIFO base address register
    @Register(bitWidth: 32)
    public struct RXFIFO_START_ADDR {
        /// This is the I2C rxfifo first address.
        @ReadOnly(bits: 0..<32)
        public var rxfifo_start_addr_field: RXFIFO_START_ADDR_FIELD
    }
}

extension I2C0.COMD {
    public struct Opcode: BitFieldProjectable, RawRepresentable {
        public static let bitWidth = 3

        /// WRITE opcode
        public nonisolated(unsafe) static let Write = Self(rawValue: 0x1)

        /// STOP opcode
        public nonisolated(unsafe) static let Stop = Self(rawValue: 0x2)

        /// READ opcode
        public nonisolated(unsafe) static let Read = Self(rawValue: 0x3)

        /// END opcode
        public nonisolated(unsafe) static let End = Self(rawValue: 0x4)

        /// RSTART opcode
        public nonisolated(unsafe) static let Rstart = Self(rawValue: 0x6)

        public var rawValue: UInt8

        @inlinable @inline(__always)
        public init(rawValue: Self.RawValue) {
            self.rawValue = rawValue
        }
    }
}
