// Generated by svd2swift.

import MMIO

/// Remote Control
@RegisterBlock
public struct RMT {
    /// The read and write data register for CHANNEL%s by apb fifo access.
    @RegisterBlock(offset: 0x0, stride: 0x4, count: 4)
    public var chdata: RegisterArray<CHDATA>

    /// Channel %s configure register 0
    @RegisterBlock(offset: 0x10, stride: 0x4, count: 2)
    public var ch_tx_conf0: RegisterArray<CH_TX_CONF0>

    /// Channel %s configure register 0
    @RegisterBlock(offset: 0x18, stride: 0x8, count: 2)
    public var ch_rx_conf0: RegisterArray<CH_RX_CONF0>

    /// Channel %s configure register 1
    @RegisterBlock(offset: 0x1c, stride: 0x8, count: 2)
    public var ch_rx_conf1: RegisterArray<CH_RX_CONF1>

    /// Channel %s status register
    @RegisterBlock(offset: 0x28, stride: 0x4, count: 2)
    public var ch_tx_status: RegisterArray<CH_TX_STATUS>

    /// Channel %s status register
    @RegisterBlock(offset: 0x30, stride: 0x4, count: 2)
    public var ch_rx_status: RegisterArray<CH_RX_STATUS>

    /// Raw interrupt status
    @RegisterBlock(offset: 0x38)
    public var int_raw: Register<INT_RAW>

    /// Masked interrupt status
    @RegisterBlock(offset: 0x3c)
    public var int_st: Register<INT_ST>

    /// Interrupt enable bits
    @RegisterBlock(offset: 0x40)
    public var int_ena: Register<INT_ENA>

    /// Interrupt clear bits
    @RegisterBlock(offset: 0x44)
    public var int_clr: Register<INT_CLR>

    /// Channel %s duty cycle configuration register
    @RegisterBlock(offset: 0x48, stride: 0x4, count: 2)
    public var chcarrier_duty: RegisterArray<CHCARRIER_DUTY>

    /// Channel %s carrier remove register
    @RegisterBlock(offset: 0x50, stride: 0x4, count: 2)
    public var ch_rx_carrier_rm: RegisterArray<CH_RX_CARRIER_RM>

    /// Channel %s Tx event configuration register
    @RegisterBlock(offset: 0x58, stride: 0x4, count: 2)
    public var ch_tx_lim: RegisterArray<CH_TX_LIM>

    /// Channel %s Rx event configuration register
    @RegisterBlock(offset: 0x60, stride: 0x4, count: 2)
    public var ch_rx_lim: RegisterArray<CH_RX_LIM>

    /// RMT apb configuration register
    @RegisterBlock(offset: 0x68)
    public var sys_conf: Register<SYS_CONF>

    /// RMT TX synchronous register
    @RegisterBlock(offset: 0x6c)
    public var tx_sim: Register<TX_SIM>

    /// RMT clock divider reset register
    @RegisterBlock(offset: 0x70)
    public var ref_cnt_rst: Register<REF_CNT_RST>

    /// RMT version register
    @RegisterBlock(offset: 0xcc)
    public var date: Register<DATE>
}

extension RMT {
    /// The read and write data register for CHANNEL%s by apb fifo access.
    @Register(bitWidth: 32)
    public struct CHDATA {
        /// Read and write data for channel %s via APB FIFO.
        @ReadWrite(bits: 0..<32)
        public var data: DATA
    }

    /// Channel %s configure register 0
    @Register(bitWidth: 32)
    public struct CH_TX_CONF0 {
        /// Set this bit to start sending data on CHANNEL%s.
        @WriteOnly(bits: 0..<1)
        public var tx_start: TX_START

        /// Set this bit to reset read ram address for CHANNEL%s by accessing transmitter.
        @WriteOnly(bits: 1..<2)
        public var mem_rd_rst: MEM_RD_RST

        /// Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        @WriteOnly(bits: 2..<3)
        public var apb_mem_rst: APB_MEM_RST

        /// Set this bit to restart transmission from the first data to the last data in CHANNEL%s.
        @ReadWrite(bits: 3..<4)
        public var tx_conti_mode: TX_CONTI_MODE

        /// This is the channel %s enable bit for wraparound mode: it will resume sending at the start when the data to be sent is more than its memory size.
        @ReadWrite(bits: 4..<5)
        public var mem_tx_wrap_en: MEM_TX_WRAP_EN

        /// This bit configures the level of output signal in CHANNEL%s when the latter is in IDLE state.
        @ReadWrite(bits: 5..<6)
        public var idle_out_lv: IDLE_OUT_LV

        /// This is the output enable-control bit for CHANNEL%s in IDLE state.
        @ReadWrite(bits: 6..<7)
        public var idle_out_en: IDLE_OUT_EN

        /// Set this bit to stop the transmitter of CHANNEL%s sending data out.
        @ReadWrite(bits: 7..<8)
        public var tx_stop: TX_STOP

        /// This register is used to configure the divider for clock of CHANNEL%s.
        @ReadWrite(bits: 8..<16)
        public var div_cnt: DIV_CNT

        /// This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        @ReadWrite(bits: 16..<19)
        public var mem_size: MEM_SIZE

        /// 1: Add carrier modulation on the output signal only at the send data state for CHANNEL%s. 0: Add carrier modulation on the output signal at all state for CHANNEL%s. Only valid when RMT_CARRIER_EN_CH%s is 1.
        @ReadWrite(bits: 20..<21)
        public var carrier_eff_en: CARRIER_EFF_EN

        /// This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        @ReadWrite(bits: 21..<22)
        public var carrier_en: CARRIER_EN

        /// 1'h1: add carrier wave on high level.
        @ReadWrite(bits: 22..<23)
        public var carrier_out_lv: CARRIER_OUT_LV

        /// Reserved
        @WriteOnly(bits: 23..<24)
        public var afifo_rst: AFIFO_RST

        /// synchronization bit for CHANNEL%s
        @WriteOnly(bits: 24..<25)
        public var conf_update: CONF_UPDATE
    }

    /// Channel %s configure register 0
    @Register(bitWidth: 32)
    public struct CH_RX_CONF0 {
        /// This register is used to configure the divider for clock of CHANNEL%s.
        @ReadWrite(bits: 0..<8)
        public var div_cnt: DIV_CNT

        /// When no edge is detected on the input signal and continuous clock cycles is longer than this register value, received process is finished.
        @ReadWrite(bits: 8..<23)
        public var idle_thres: IDLE_THRES

        /// This register is used to configure the maximum size of memory allocated to CHANNEL%s.
        @ReadWrite(bits: 23..<26)
        public var mem_size: MEM_SIZE

        /// This is the carrier modulation enable-control bit for CHANNEL%s. 1: Add carrier modulation in the output signal. 0: No carrier modulation in sig_out.
        @ReadWrite(bits: 28..<29)
        public var carrier_en: CARRIER_EN

        /// 1'h1: add carrier wave on high level.
        @ReadWrite(bits: 29..<30)
        public var carrier_out_lv: CARRIER_OUT_LV
    }

    /// Channel %s configure register 1
    @Register(bitWidth: 32)
    public struct CH_RX_CONF1 {
        /// Set this bit to enable receiver to receive data on CHANNEL%s.
        @ReadWrite(bits: 0..<1)
        public var rx_en: RX_EN

        /// Set this bit to reset write ram address for CHANNEL%s by accessing receiver.
        @WriteOnly(bits: 1..<2)
        public var mem_wr_rst: MEM_WR_RST

        /// Set this bit to reset W/R ram address for CHANNEL%s by accessing apb fifo.
        @WriteOnly(bits: 2..<3)
        public var apb_mem_rst: APB_MEM_RST

        /// 1'h0: APB bus is using the ram.
        @ReadWrite(bits: 3..<4)
        public var mem_owner: MEM_OWNER

        /// This is the receive filter's enable bit for CHANNEL%s.
        @ReadWrite(bits: 4..<5)
        public var rx_filter_en: RX_FILTER_EN

        /// Ignores the input pulse when its width is smaller than this register value in APB clock periods (in receive mode).
        @ReadWrite(bits: 5..<13)
        public var rx_filter_thres: RX_FILTER_THRES

        /// This is the channel %s enable bit for wraparound mode: it will resume receiving at the start when the data to be received is more than its memory size.
        @ReadWrite(bits: 13..<14)
        public var mem_rx_wrap_en: MEM_RX_WRAP_EN

        /// Reserved
        @WriteOnly(bits: 14..<15)
        public var afifo_rst: AFIFO_RST

        /// synchronization bit for CHANNEL%s
        @WriteOnly(bits: 15..<16)
        public var conf_update: CONF_UPDATE
    }

    /// Channel %s status register
    @Register(bitWidth: 32)
    public struct CH_TX_STATUS {
        /// This register records the memory address offset when transmitter of CHANNEL%s is using the RAM.
        @ReadOnly(bits: 0..<9)
        public var mem_raddr_ex: MEM_RADDR_EX

        /// This register records the FSM status of CHANNEL%s.
        @ReadOnly(bits: 9..<12)
        public var state: STATE

        /// This register records the memory address offset when writes RAM over APB bus.
        @ReadOnly(bits: 12..<21)
        public var apb_mem_waddr: APB_MEM_WADDR

        /// This status bit will be set if the offset address out of memory size when reading via APB bus.
        @ReadOnly(bits: 21..<22)
        public var apb_mem_rd_err: APB_MEM_RD_ERR

        /// This status bit will be set when the data to be set is more than memory size and the wraparound mode is disabled.
        @ReadOnly(bits: 22..<23)
        public var mem_empty: MEM_EMPTY

        /// This status bit will be set if the offset address out of memory size when writes via APB bus.
        @ReadOnly(bits: 23..<24)
        public var apb_mem_wr_err: APB_MEM_WR_ERR

        /// This register records the memory address offset when reading RAM over APB bus.
        @ReadOnly(bits: 24..<32)
        public var apb_mem_raddr: APB_MEM_RADDR
    }

    /// Channel %s status register
    @Register(bitWidth: 32)
    public struct CH_RX_STATUS {
        /// This register records the memory address offset when receiver of CHANNEL%s is using the RAM.
        @ReadOnly(bits: 0..<9)
        public var mem_waddr_ex: MEM_WADDR_EX

        /// This register records the memory address offset when reads RAM over APB bus.
        @ReadOnly(bits: 12..<21)
        public var apb_mem_raddr: APB_MEM_RADDR

        /// This register records the FSM status of CHANNEL%s.
        @ReadOnly(bits: 22..<25)
        public var state: STATE

        /// This status bit will be set when the ownership of memory block is wrong.
        @ReadOnly(bits: 25..<26)
        public var mem_owner_err: MEM_OWNER_ERR

        /// This status bit will be set if the receiver receives more data than the memory size.
        @ReadOnly(bits: 26..<27)
        public var mem_full: MEM_FULL

        /// This status bit will be set if the offset address out of memory size when reads via APB bus.
        @ReadOnly(bits: 27..<28)
        public var apb_mem_rd_err: APB_MEM_RD_ERR
    }

    /// Raw interrupt status
    @Register(bitWidth: 32)
    public struct INT_RAW {
        /// The interrupt raw bit for CHANNEL%s. Triggered when transmission done.
        @ReadWrite(bits: 0..<1)
        public var ch_tx_end0: CH_TX_END0

        /// The interrupt raw bit for CHANNEL%s. Triggered when transmission done.
        @ReadWrite(bits: 1..<2)
        public var ch_tx_end1: CH_TX_END1

        /// The interrupt raw bit for CHANNEL2. Triggered when reception done.
        @ReadWrite(bits: 2..<3)
        public var ch_rx_end0: CH_RX_END0

        /// The interrupt raw bit for CHANNEL2. Triggered when reception done.
        @ReadWrite(bits: 3..<4)
        public var ch_rx_end1: CH_RX_END1

        /// The interrupt raw bit for CHANNEL4. Triggered when error occurs.
        @ReadWrite(bits: 4..<5)
        public var ch_tx_err0: CH_TX_ERR0

        /// The interrupt raw bit for CHANNEL4. Triggered when error occurs.
        @ReadWrite(bits: 5..<6)
        public var ch_tx_err1: CH_TX_ERR1

        /// The interrupt raw bit for CHANNEL6. Triggered when error occurs.
        @ReadWrite(bits: 6..<7)
        public var ch_rx_err0: CH_RX_ERR0

        /// The interrupt raw bit for CHANNEL6. Triggered when error occurs.
        @ReadWrite(bits: 7..<8)
        public var ch_rx_err1: CH_RX_ERR1

        /// The interrupt raw bit for CHANNEL%s. Triggered when transmitter sent more data than configured value.
        @ReadWrite(bits: 8..<9)
        public var ch_tx_thr_event0: CH_TX_THR_EVENT0

        /// The interrupt raw bit for CHANNEL%s. Triggered when transmitter sent more data than configured value.
        @ReadWrite(bits: 9..<10)
        public var ch_tx_thr_event1: CH_TX_THR_EVENT1

        /// The interrupt raw bit for CHANNEL2. Triggered when receiver receive more data than configured value.
        @ReadWrite(bits: 10..<11)
        public var ch_rx_thr_event0: CH_RX_THR_EVENT0

        /// The interrupt raw bit for CHANNEL2. Triggered when receiver receive more data than configured value.
        @ReadWrite(bits: 11..<12)
        public var ch_rx_thr_event1: CH_RX_THR_EVENT1

        /// The interrupt raw bit for CHANNEL%s. Triggered when the loop count reaches the configured threshold value.
        @ReadWrite(bits: 12..<13)
        public var ch_tx_loop0: CH_TX_LOOP0

        /// The interrupt raw bit for CHANNEL%s. Triggered when the loop count reaches the configured threshold value.
        @ReadWrite(bits: 13..<14)
        public var ch_tx_loop1: CH_TX_LOOP1
    }

    /// Masked interrupt status
    @Register(bitWidth: 32)
    public struct INT_ST {
        /// The masked interrupt status bit for CH%s_TX_END_INT.
        @ReadOnly(bits: 0..<1)
        public var ch_tx_end0: CH_TX_END0

        /// The masked interrupt status bit for CH%s_TX_END_INT.
        @ReadOnly(bits: 1..<2)
        public var ch_tx_end1: CH_TX_END1

        /// The masked interrupt status bit for CH2_RX_END_INT.
        @ReadOnly(bits: 2..<3)
        public var ch_rx_end0: CH_RX_END0

        /// The masked interrupt status bit for CH2_RX_END_INT.
        @ReadOnly(bits: 3..<4)
        public var ch_rx_end1: CH_RX_END1

        /// The masked interrupt status bit for CH4_ERR_INT.
        @ReadOnly(bits: 4..<5)
        public var ch_tx_err0: CH_TX_ERR0

        /// The masked interrupt status bit for CH4_ERR_INT.
        @ReadOnly(bits: 5..<6)
        public var ch_tx_err1: CH_TX_ERR1

        /// The masked interrupt status bit for CH6_ERR_INT.
        @ReadOnly(bits: 6..<7)
        public var ch_rx_err0: CH_RX_ERR0

        /// The masked interrupt status bit for CH6_ERR_INT.
        @ReadOnly(bits: 7..<8)
        public var ch_rx_err1: CH_RX_ERR1

        /// The masked interrupt status bit for CH%s_TX_THR_EVENT_INT.
        @ReadOnly(bits: 8..<9)
        public var ch_tx_thr_event0: CH_TX_THR_EVENT0

        /// The masked interrupt status bit for CH%s_TX_THR_EVENT_INT.
        @ReadOnly(bits: 9..<10)
        public var ch_tx_thr_event1: CH_TX_THR_EVENT1

        /// The masked interrupt status bit for CH2_RX_THR_EVENT_INT.
        @ReadOnly(bits: 10..<11)
        public var ch_rx_thr_event0: CH_RX_THR_EVENT0

        /// The masked interrupt status bit for CH2_RX_THR_EVENT_INT.
        @ReadOnly(bits: 11..<12)
        public var ch_rx_thr_event1: CH_RX_THR_EVENT1

        /// The masked interrupt status bit for CH%s_TX_LOOP_INT.
        @ReadOnly(bits: 12..<13)
        public var ch_x_loop0: CH_X_LOOP0

        /// The masked interrupt status bit for CH%s_TX_LOOP_INT.
        @ReadOnly(bits: 13..<14)
        public var ch_x_loop1: CH_X_LOOP1
    }

    /// Interrupt enable bits
    @Register(bitWidth: 32)
    public struct INT_ENA {
        /// The interrupt enable bit for CH%s_TX_END_INT.
        @ReadWrite(bits: 0..<1)
        public var ch_tx_end0: CH_TX_END0

        /// The interrupt enable bit for CH%s_TX_END_INT.
        @ReadWrite(bits: 1..<2)
        public var ch_tx_end1: CH_TX_END1

        /// The interrupt enable bit for CH2_RX_END_INT.
        @ReadWrite(bits: 2..<3)
        public var ch_rx_end0: CH_RX_END0

        /// The interrupt enable bit for CH2_RX_END_INT.
        @ReadWrite(bits: 3..<4)
        public var ch_rx_end1: CH_RX_END1

        /// The interrupt enable bit for CH4_ERR_INT.
        @ReadWrite(bits: 4..<5)
        public var ch_tx_err0: CH_TX_ERR0

        /// The interrupt enable bit for CH4_ERR_INT.
        @ReadWrite(bits: 5..<6)
        public var ch_tx_err1: CH_TX_ERR1

        /// The interrupt enable bit for CH6_ERR_INT.
        @ReadWrite(bits: 6..<7)
        public var ch_rx_err0: CH_RX_ERR0

        /// The interrupt enable bit for CH6_ERR_INT.
        @ReadWrite(bits: 7..<8)
        public var ch_rx_err1: CH_RX_ERR1

        /// The interrupt enable bit for CH%s_TX_THR_EVENT_INT.
        @ReadWrite(bits: 8..<9)
        public var ch_tx_thr_event0: CH_TX_THR_EVENT0

        /// The interrupt enable bit for CH%s_TX_THR_EVENT_INT.
        @ReadWrite(bits: 9..<10)
        public var ch_tx_thr_event1: CH_TX_THR_EVENT1

        /// The interrupt enable bit for CH2_RX_THR_EVENT_INT.
        @ReadWrite(bits: 10..<11)
        public var ch_rx_thr_event0: CH_RX_THR_EVENT0

        /// The interrupt enable bit for CH2_RX_THR_EVENT_INT.
        @ReadWrite(bits: 11..<12)
        public var ch_rx_thr_event1: CH_RX_THR_EVENT1

        /// The interrupt enable bit for CH%s_TX_LOOP_INT.
        @ReadWrite(bits: 12..<13)
        public var ch_x_loop0: CH_X_LOOP0

        /// The interrupt enable bit for CH%s_TX_LOOP_INT.
        @ReadWrite(bits: 13..<14)
        public var ch_x_loop1: CH_X_LOOP1
    }

    /// Interrupt clear bits
    @Register(bitWidth: 32)
    public struct INT_CLR {
        /// Set this bit to clear theCH%s_TX_END_INT interrupt.
        @WriteOnly(bits: 0..<1)
        public var ch_tx_end0: CH_TX_END0

        /// Set this bit to clear theCH%s_TX_END_INT interrupt.
        @WriteOnly(bits: 1..<2)
        public var ch_tx_end1: CH_TX_END1

        /// Set this bit to clear theCH2_RX_END_INT interrupt.
        @WriteOnly(bits: 2..<3)
        public var ch_rx_end0: CH_RX_END0

        /// Set this bit to clear theCH2_RX_END_INT interrupt.
        @WriteOnly(bits: 3..<4)
        public var ch_rx_end1: CH_RX_END1

        /// Set this bit to clear theCH4_ERR_INT interrupt.
        @WriteOnly(bits: 4..<5)
        public var ch_tx_err0: CH_TX_ERR0

        /// Set this bit to clear theCH4_ERR_INT interrupt.
        @WriteOnly(bits: 5..<6)
        public var ch_tx_err1: CH_TX_ERR1

        /// Set this bit to clear theCH6_ERR_INT interrupt.
        @WriteOnly(bits: 6..<7)
        public var ch_rx_err0: CH_RX_ERR0

        /// Set this bit to clear theCH6_ERR_INT interrupt.
        @WriteOnly(bits: 7..<8)
        public var ch_rx_err1: CH_RX_ERR1

        /// Set this bit to clear theCH%s_TX_THR_EVENT_INT interrupt.
        @WriteOnly(bits: 8..<9)
        public var ch_tx_thr_event0: CH_TX_THR_EVENT0

        /// Set this bit to clear theCH%s_TX_THR_EVENT_INT interrupt.
        @WriteOnly(bits: 9..<10)
        public var ch_tx_thr_event1: CH_TX_THR_EVENT1

        /// Set this bit to clear theCH2_RX_THR_EVENT_INT interrupt.
        @WriteOnly(bits: 10..<11)
        public var ch_rx_thr_event0: CH_RX_THR_EVENT0

        /// Set this bit to clear theCH2_RX_THR_EVENT_INT interrupt.
        @WriteOnly(bits: 11..<12)
        public var ch_rx_thr_event1: CH_RX_THR_EVENT1

        /// Set this bit to clear theCH%s_TX_LOOP_INT interrupt.
        @WriteOnly(bits: 12..<13)
        public var ch_tx_loop0: CH_TX_LOOP0

        /// Set this bit to clear theCH%s_TX_LOOP_INT interrupt.
        @WriteOnly(bits: 13..<14)
        public var ch_tx_loop1: CH_TX_LOOP1
    }

    /// Channel %s duty cycle configuration register
    @Register(bitWidth: 32)
    public struct CHCARRIER_DUTY {
        /// This register is used to configure carrier wave 's low level clock period for CHANNEL%s.
        @ReadWrite(bits: 0..<16)
        public var carrier_low: CARRIER_LOW

        /// This register is used to configure carrier wave 's high level clock period for CHANNEL%s.
        @ReadWrite(bits: 16..<32)
        public var carrier_high: CARRIER_HIGH
    }

    /// Channel %s carrier remove register
    @Register(bitWidth: 32)
    public struct CH_RX_CARRIER_RM {
        /// The low level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_LOW_THRES_CH%s + 1) for channel %s.
        @ReadWrite(bits: 0..<16)
        public var carrier_low_thres: CARRIER_LOW_THRES

        /// The high level period in a carrier modulation mode is (REG_RMT_REG_CARRIER_HIGH_THRES_CH%s + 1) for channel %s.
        @ReadWrite(bits: 16..<32)
        public var carrier_high_thres: CARRIER_HIGH_THRES
    }

    /// Channel %s Tx event configuration register
    @Register(bitWidth: 32)
    public struct CH_TX_LIM {
        /// This register is used to configure the maximum entries that CHANNEL%s can send out.
        @ReadWrite(bits: 0..<9)
        public var tx_lim: TX_LIM

        /// This register is used to configure the maximum loop count when tx_conti_mode is valid.
        @ReadWrite(bits: 9..<19)
        public var tx_loop_num: TX_LOOP_NUM

        /// This register is the enabled bit for loop count.
        @ReadWrite(bits: 19..<20)
        public var tx_loop_cnt_en: TX_LOOP_CNT_EN

        /// This register is used to reset the loop count when tx_conti_mode is valid.
        @WriteOnly(bits: 20..<21)
        public var loop_count_reset: LOOP_COUNT_RESET

        /// This bit is used to enable the loop send stop function after the loop counter counts to loop number for CHANNEL%s.
        @ReadWrite(bits: 21..<22)
        public var loop_stop_en: LOOP_STOP_EN
    }

    /// Channel %s Rx event configuration register
    @Register(bitWidth: 32)
    public struct CH_RX_LIM {
        /// This register is used to configure the maximum entries that CHANNEL%s can receive.
        @ReadWrite(bits: 0..<9)
        public var rmt_rx_lim: RMT_RX_LIM
    }

    /// RMT apb configuration register
    @Register(bitWidth: 32)
    public struct SYS_CONF {
        /// 1'h1: access memory directly. 1'h0: access memory by FIFO.
        @ReadWrite(bits: 0..<1)
        public var apb_fifo_mask: APB_FIFO_MASK

        /// Set this bit to enable the clock for RMT memory.
        @ReadWrite(bits: 1..<2)
        public var mem_clk_force_on: MEM_CLK_FORCE_ON

        /// Set this bit to power down RMT memory.
        @ReadWrite(bits: 2..<3)
        public var mem_force_pd: MEM_FORCE_PD

        /// 1: Disable RMT memory light sleep power down function. 0: Power down RMT memory when RMT is in light sleep mode.
        @ReadWrite(bits: 3..<4)
        public var mem_force_pu: MEM_FORCE_PU

        /// RMT register clock gate enable signal. 1: Power up the drive clock of registers. 0: Power down the drive clock of registers
        @ReadWrite(bits: 31..<32)
        public var clk_en: CLK_EN
    }

    /// RMT TX synchronous register
    @Register(bitWidth: 32)
    public struct TX_SIM {
        /// Set this bit to enable CHANNEL0 to start sending data synchronously with other enabled channels.
        @ReadWrite(bits: 0..<1)
        public var ch0: CH0

        /// Set this bit to enable CHANNEL1 to start sending data synchronously with other enabled channels.
        @ReadWrite(bits: 1..<2)
        public var ch1: CH1

        /// This register is used to enable multiple of channels to start sending data synchronously.
        @ReadWrite(bits: 2..<3)
        public var en: EN
    }

    /// RMT clock divider reset register
    @Register(bitWidth: 32)
    public struct REF_CNT_RST {
        /// This register is used to reset the clock divider of CHANNEL0.
        @WriteOnly(bits: 0..<1)
        public var tx_ref_cnt_rst: TX_REF_CNT_RST

        /// This register is used to reset the clock divider of CHANNEL1.
        @WriteOnly(bits: 1..<2)
        public var tx_ref_cnt_rst_ch1: TX_REF_CNT_RST_CH1

        /// This register is used to reset the clock divider of CHANNEL2.
        @WriteOnly(bits: 2..<3)
        public var rx_ref_cnt_rst_ch2: RX_REF_CNT_RST_CH2

        /// This register is used to reset the clock divider of CHANNEL3.
        @WriteOnly(bits: 3..<4)
        public var rx_ref_cnt_rst_ch3: RX_REF_CNT_RST_CH3
    }

    /// RMT version register
    @Register(bitWidth: 32)
    public struct DATE {
        /// This is the version register.
        @ReadWrite(bits: 0..<28)
        public var rmt_date: RMT_DATE
    }
}
