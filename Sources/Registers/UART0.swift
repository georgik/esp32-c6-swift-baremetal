// Generated by svd2swift.

import MMIO

/// UART (Universal Asynchronous Receiver-Transmitter) Controller 0
@RegisterBlock
public struct UART0 {
    /// FIFO data register
    @RegisterBlock(offset: 0x0)
    public var fifo: Register<FIFO>

    /// Raw interrupt status
    @RegisterBlock(offset: 0x4)
    public var int_raw: Register<INT_RAW>

    /// Masked interrupt status
    @RegisterBlock(offset: 0x8)
    public var int_st: Register<INT_ST>

    /// Interrupt enable bits
    @RegisterBlock(offset: 0xc)
    public var int_ena: Register<INT_ENA>

    /// Interrupt clear bits
    @RegisterBlock(offset: 0x10)
    public var int_clr: Register<INT_CLR>

    /// Clock divider configuration
    @RegisterBlock(offset: 0x14)
    public var clkdiv: Register<CLKDIV>

    /// Rx Filter configuration
    @RegisterBlock(offset: 0x18)
    public var rx_filt: Register<RX_FILT>

    /// UART status register
    @RegisterBlock(offset: 0x1c)
    public var status: Register<STATUS>

    /// a
    @RegisterBlock(offset: 0x20)
    public var conf0: Register<CONF0>

    /// Configuration register 1
    @RegisterBlock(offset: 0x24)
    public var conf1: Register<CONF1>

    /// Hardware flow-control configuration
    @RegisterBlock(offset: 0x2c)
    public var hwfc_conf: Register<HWFC_CONF>

    /// UART sleep configure register 0
    @RegisterBlock(offset: 0x30)
    public var sleep_conf0: Register<SLEEP_CONF0>

    /// UART sleep configure register 1
    @RegisterBlock(offset: 0x34)
    public var sleep_conf1: Register<SLEEP_CONF1>

    /// UART sleep configure register 2
    @RegisterBlock(offset: 0x38)
    public var sleep_conf2: Register<SLEEP_CONF2>

    /// Software flow-control character configuration
    @RegisterBlock(offset: 0x3c)
    public var swfc_conf0: Register<SWFC_CONF0>

    /// Software flow-control character configuration
    @RegisterBlock(offset: 0x40)
    public var swfc_conf1: Register<SWFC_CONF1>

    /// Tx Break character configuration
    @RegisterBlock(offset: 0x44)
    public var txbrk_conf: Register<TXBRK_CONF>

    /// Frame-end idle configuration
    @RegisterBlock(offset: 0x48)
    public var idle_conf: Register<IDLE_CONF>

    /// RS485 mode configuration
    @RegisterBlock(offset: 0x4c)
    public var rs485_conf: Register<RS485_CONF>

    /// Pre-sequence timing configuration
    @RegisterBlock(offset: 0x50)
    public var at_cmd_precnt: Register<AT_CMD_PRECNT>

    /// Post-sequence timing configuration
    @RegisterBlock(offset: 0x54)
    public var at_cmd_postcnt: Register<AT_CMD_POSTCNT>

    /// Timeout configuration
    @RegisterBlock(offset: 0x58)
    public var at_cmd_gaptout: Register<AT_CMD_GAPTOUT>

    /// AT escape sequence detection configuration
    @RegisterBlock(offset: 0x5c)
    public var at_cmd_char: Register<AT_CMD_CHAR>

    /// UART memory power configuration
    @RegisterBlock(offset: 0x60)
    public var mem_conf: Register<MEM_CONF>

    /// UART threshold and allocation configuration
    @RegisterBlock(offset: 0x64)
    public var tout_conf: Register<TOUT_CONF>

    /// Tx-SRAM write and read offset address.
    @RegisterBlock(offset: 0x68)
    public var mem_tx_status: Register<MEM_TX_STATUS>

    /// Rx-SRAM write and read offset address.
    @RegisterBlock(offset: 0x6c)
    public var mem_rx_status: Register<MEM_RX_STATUS>

    /// UART transmit and receive status.
    @RegisterBlock(offset: 0x70)
    public var fsm_status: Register<FSM_STATUS>

    /// Autobaud high pulse register
    @RegisterBlock(offset: 0x74)
    public var pospulse: Register<POSPULSE>

    /// Autobaud low pulse register
    @RegisterBlock(offset: 0x78)
    public var negpulse: Register<NEGPULSE>

    /// Autobaud minimum low pulse duration register
    @RegisterBlock(offset: 0x7c)
    public var lowpulse: Register<LOWPULSE>

    /// Autobaud minimum high pulse duration register
    @RegisterBlock(offset: 0x80)
    public var highpulse: Register<HIGHPULSE>

    /// Autobaud edge change count register
    @RegisterBlock(offset: 0x84)
    public var rxd_cnt: Register<RXD_CNT>

    /// UART core clock configuration
    @RegisterBlock(offset: 0x88)
    public var clk_conf: Register<CLK_CONF>

    /// UART Version register
    @RegisterBlock(offset: 0x8c)
    public var date: Register<DATE>

    /// UART AFIFO Status
    @RegisterBlock(offset: 0x90)
    public var afifo_status: Register<AFIFO_STATUS>

    /// UART Registers Configuration Update register
    @RegisterBlock(offset: 0x98)
    public var reg_update: Register<REG_UPDATE>

    /// UART ID register
    @RegisterBlock(offset: 0x9c)
    public var id: Register<ID>
}

extension UART0 {
    /// FIFO data register
    @Register(bitWidth: 32)
    public struct FIFO {
        /// UART 0 accesses FIFO via this register.
        @ReadWrite(bits: 0..<8)
        public var rxfifo_rd_byte: RXFIFO_RD_BYTE
    }

    /// Raw interrupt status
    @Register(bitWidth: 32)
    public struct INT_RAW {
        /// This interrupt raw bit turns to high level when receiver receives more data than what rxfifo_full_thrhd specifies.
        @ReadWrite(bits: 0..<1)
        public var rxfifo_full: RXFIFO_FULL

        /// This interrupt raw bit turns to high level when the amount of data in Tx-FIFO is less than what txfifo_empty_thrhd specifies .
        @ReadWrite(bits: 1..<2)
        public var txfifo_empty: TXFIFO_EMPTY

        /// This interrupt raw bit turns to high level when receiver detects a parity error in the data.
        @ReadWrite(bits: 2..<3)
        public var parity_err: PARITY_ERR

        /// This interrupt raw bit turns to high level when receiver detects a data frame error .
        @ReadWrite(bits: 3..<4)
        public var frm_err: FRM_ERR

        /// This interrupt raw bit turns to high level when receiver receives more data than the FIFO can store.
        @ReadWrite(bits: 4..<5)
        public var rxfifo_ovf: RXFIFO_OVF

        /// This interrupt raw bit turns to high level when receiver detects the edge change of DSRn signal.
        @ReadWrite(bits: 5..<6)
        public var dsr_chg: DSR_CHG

        /// This interrupt raw bit turns to high level when receiver detects the edge change of CTSn signal.
        @ReadWrite(bits: 6..<7)
        public var cts_chg: CTS_CHG

        /// This interrupt raw bit turns to high level when receiver detects a 0 after the stop bit.
        @ReadWrite(bits: 7..<8)
        public var brk_det: BRK_DET

        /// This interrupt raw bit turns to high level when receiver takes more time than rx_tout_thrhd to receive a byte.
        @ReadWrite(bits: 8..<9)
        public var rxfifo_tout: RXFIFO_TOUT

        /// This interrupt raw bit turns to high level when receiver recevies Xon char when uart_sw_flow_con_en is set to 1.
        @ReadWrite(bits: 9..<10)
        public var sw_xon: SW_XON

        /// This interrupt raw bit turns to high level when receiver receives Xoff char when uart_sw_flow_con_en is set to 1.
        @ReadWrite(bits: 10..<11)
        public var sw_xoff: SW_XOFF

        /// This interrupt raw bit turns to high level when receiver detects a glitch in the middle of a start bit.
        @ReadWrite(bits: 11..<12)
        public var glitch_det: GLITCH_DET

        /// This interrupt raw bit turns to high level when transmitter completes sending NULL characters after all data in Tx-FIFO are sent.
        @ReadWrite(bits: 12..<13)
        public var tx_brk_done: TX_BRK_DONE

        /// This interrupt raw bit turns to high level when transmitter has kept the shortest duration after sending the last data.
        @ReadWrite(bits: 13..<14)
        public var tx_brk_idle_done: TX_BRK_IDLE_DONE

        /// This interrupt raw bit turns to high level when transmitter has send out all data in FIFO.
        @ReadWrite(bits: 14..<15)
        public var tx_done: TX_DONE

        /// This interrupt raw bit turns to high level when receiver detects a parity error from the echo of transmitter in rs485 mode.
        @ReadWrite(bits: 15..<16)
        public var rs485_parity_err: RS485_PARITY_ERR

        /// This interrupt raw bit turns to high level when receiver detects a data frame error from the echo of transmitter in rs485 mode.
        @ReadWrite(bits: 16..<17)
        public var rs485_frm_err: RS485_FRM_ERR

        /// This interrupt raw bit turns to high level when detects a clash between transmitter and receiver in rs485 mode.
        @ReadWrite(bits: 17..<18)
        public var rs485_clash: RS485_CLASH

        /// This interrupt raw bit turns to high level when receiver detects the configured at_cmd char.
        @ReadWrite(bits: 18..<19)
        public var at_cmd_char_det: AT_CMD_CHAR_DET

        /// This interrupt raw bit turns to high level when input rxd edge changes more times than what reg_active_threshold specifies in light sleeping mode.
        @ReadWrite(bits: 19..<20)
        public var wakeup: WAKEUP
    }

    /// Masked interrupt status
    @Register(bitWidth: 32)
    public struct INT_ST {
        /// This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena is set to 1.
        @ReadOnly(bits: 0..<1)
        public var rxfifo_full: RXFIFO_FULL

        /// This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena is set to 1.
        @ReadOnly(bits: 1..<2)
        public var txfifo_empty: TXFIFO_EMPTY

        /// This is the status bit for parity_err_int_raw when parity_err_int_ena is set to 1.
        @ReadOnly(bits: 2..<3)
        public var parity_err: PARITY_ERR

        /// This is the status bit for frm_err_int_raw when frm_err_int_ena is set to 1.
        @ReadOnly(bits: 3..<4)
        public var frm_err: FRM_ERR

        /// This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena is set to 1.
        @ReadOnly(bits: 4..<5)
        public var rxfifo_ovf: RXFIFO_OVF

        /// This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena is set to 1.
        @ReadOnly(bits: 5..<6)
        public var dsr_chg: DSR_CHG

        /// This is the status bit for cts_chg_int_raw when cts_chg_int_ena is set to 1.
        @ReadOnly(bits: 6..<7)
        public var cts_chg: CTS_CHG

        /// This is the status bit for brk_det_int_raw when brk_det_int_ena is set to 1.
        @ReadOnly(bits: 7..<8)
        public var brk_det: BRK_DET

        /// This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena is set to 1.
        @ReadOnly(bits: 8..<9)
        public var rxfifo_tout: RXFIFO_TOUT

        /// This is the status bit for sw_xon_int_raw when sw_xon_int_ena is set to 1.
        @ReadOnly(bits: 9..<10)
        public var sw_xon: SW_XON

        /// This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena is set to 1.
        @ReadOnly(bits: 10..<11)
        public var sw_xoff: SW_XOFF

        /// This is the status bit for glitch_det_int_raw when glitch_det_int_ena is set to 1.
        @ReadOnly(bits: 11..<12)
        public var glitch_det: GLITCH_DET

        /// This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena is set to 1.
        @ReadOnly(bits: 12..<13)
        public var tx_brk_done: TX_BRK_DONE

        /// This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_ena is set to 1.
        @ReadOnly(bits: 13..<14)
        public var tx_brk_idle_done: TX_BRK_IDLE_DONE

        /// This is the status bit for tx_done_int_raw when tx_done_int_ena is set to 1.
        @ReadOnly(bits: 14..<15)
        public var tx_done: TX_DONE

        /// This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena is set to 1.
        @ReadOnly(bits: 15..<16)
        public var rs485_parity_err: RS485_PARITY_ERR

        /// This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena is set to 1.
        @ReadOnly(bits: 16..<17)
        public var rs485_frm_err: RS485_FRM_ERR

        /// This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena is set to 1.
        @ReadOnly(bits: 17..<18)
        public var rs485_clash: RS485_CLASH

        /// This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena is set to 1.
        @ReadOnly(bits: 18..<19)
        public var at_cmd_char_det: AT_CMD_CHAR_DET

        /// This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena is set to 1.
        @ReadOnly(bits: 19..<20)
        public var wakeup: WAKEUP
    }

    /// Interrupt enable bits
    @Register(bitWidth: 32)
    public struct INT_ENA {
        /// This is the enable bit for rxfifo_full_int_st register.
        @ReadWrite(bits: 0..<1)
        public var rxfifo_full: RXFIFO_FULL

        /// This is the enable bit for txfifo_empty_int_st register.
        @ReadWrite(bits: 1..<2)
        public var txfifo_empty: TXFIFO_EMPTY

        /// This is the enable bit for parity_err_int_st register.
        @ReadWrite(bits: 2..<3)
        public var parity_err: PARITY_ERR

        /// This is the enable bit for frm_err_int_st register.
        @ReadWrite(bits: 3..<4)
        public var frm_err: FRM_ERR

        /// This is the enable bit for rxfifo_ovf_int_st register.
        @ReadWrite(bits: 4..<5)
        public var rxfifo_ovf: RXFIFO_OVF

        /// This is the enable bit for dsr_chg_int_st register.
        @ReadWrite(bits: 5..<6)
        public var dsr_chg: DSR_CHG

        /// This is the enable bit for cts_chg_int_st register.
        @ReadWrite(bits: 6..<7)
        public var cts_chg: CTS_CHG

        /// This is the enable bit for brk_det_int_st register.
        @ReadWrite(bits: 7..<8)
        public var brk_det: BRK_DET

        /// This is the enable bit for rxfifo_tout_int_st register.
        @ReadWrite(bits: 8..<9)
        public var rxfifo_tout: RXFIFO_TOUT

        /// This is the enable bit for sw_xon_int_st register.
        @ReadWrite(bits: 9..<10)
        public var sw_xon: SW_XON

        /// This is the enable bit for sw_xoff_int_st register.
        @ReadWrite(bits: 10..<11)
        public var sw_xoff: SW_XOFF

        /// This is the enable bit for glitch_det_int_st register.
        @ReadWrite(bits: 11..<12)
        public var glitch_det: GLITCH_DET

        /// This is the enable bit for tx_brk_done_int_st register.
        @ReadWrite(bits: 12..<13)
        public var tx_brk_done: TX_BRK_DONE

        /// This is the enable bit for tx_brk_idle_done_int_st register.
        @ReadWrite(bits: 13..<14)
        public var tx_brk_idle_done: TX_BRK_IDLE_DONE

        /// This is the enable bit for tx_done_int_st register.
        @ReadWrite(bits: 14..<15)
        public var tx_done: TX_DONE

        /// This is the enable bit for rs485_parity_err_int_st register.
        @ReadWrite(bits: 15..<16)
        public var rs485_parity_err: RS485_PARITY_ERR

        /// This is the enable bit for rs485_parity_err_int_st register.
        @ReadWrite(bits: 16..<17)
        public var rs485_frm_err: RS485_FRM_ERR

        /// This is the enable bit for rs485_clash_int_st register.
        @ReadWrite(bits: 17..<18)
        public var rs485_clash: RS485_CLASH

        /// This is the enable bit for at_cmd_char_det_int_st register.
        @ReadWrite(bits: 18..<19)
        public var at_cmd_char_det: AT_CMD_CHAR_DET

        /// This is the enable bit for uart_wakeup_int_st register.
        @ReadWrite(bits: 19..<20)
        public var wakeup: WAKEUP
    }

    /// Interrupt clear bits
    @Register(bitWidth: 32)
    public struct INT_CLR {
        /// Set this bit to clear the rxfifo_full_int_raw interrupt.
        @WriteOnly(bits: 0..<1)
        public var rxfifo_full: RXFIFO_FULL

        /// Set this bit to clear txfifo_empty_int_raw interrupt.
        @WriteOnly(bits: 1..<2)
        public var txfifo_empty: TXFIFO_EMPTY

        /// Set this bit to clear parity_err_int_raw interrupt.
        @WriteOnly(bits: 2..<3)
        public var parity_err: PARITY_ERR

        /// Set this bit to clear frm_err_int_raw interrupt.
        @WriteOnly(bits: 3..<4)
        public var frm_err: FRM_ERR

        /// Set this bit to clear rxfifo_ovf_int_raw interrupt.
        @WriteOnly(bits: 4..<5)
        public var rxfifo_ovf: RXFIFO_OVF

        /// Set this bit to clear the dsr_chg_int_raw interrupt.
        @WriteOnly(bits: 5..<6)
        public var dsr_chg: DSR_CHG

        /// Set this bit to clear the cts_chg_int_raw interrupt.
        @WriteOnly(bits: 6..<7)
        public var cts_chg: CTS_CHG

        /// Set this bit to clear the brk_det_int_raw interrupt.
        @WriteOnly(bits: 7..<8)
        public var brk_det: BRK_DET

        /// Set this bit to clear the rxfifo_tout_int_raw interrupt.
        @WriteOnly(bits: 8..<9)
        public var rxfifo_tout: RXFIFO_TOUT

        /// Set this bit to clear the sw_xon_int_raw interrupt.
        @WriteOnly(bits: 9..<10)
        public var sw_xon: SW_XON

        /// Set this bit to clear the sw_xoff_int_raw interrupt.
        @WriteOnly(bits: 10..<11)
        public var sw_xoff: SW_XOFF

        /// Set this bit to clear the glitch_det_int_raw interrupt.
        @WriteOnly(bits: 11..<12)
        public var glitch_det: GLITCH_DET

        /// Set this bit to clear the tx_brk_done_int_raw interrupt..
        @WriteOnly(bits: 12..<13)
        public var tx_brk_done: TX_BRK_DONE

        /// Set this bit to clear the tx_brk_idle_done_int_raw interrupt.
        @WriteOnly(bits: 13..<14)
        public var tx_brk_idle_done: TX_BRK_IDLE_DONE

        /// Set this bit to clear the tx_done_int_raw interrupt.
        @WriteOnly(bits: 14..<15)
        public var tx_done: TX_DONE

        /// Set this bit to clear the rs485_parity_err_int_raw interrupt.
        @WriteOnly(bits: 15..<16)
        public var rs485_parity_err: RS485_PARITY_ERR

        /// Set this bit to clear the rs485_frm_err_int_raw interrupt.
        @WriteOnly(bits: 16..<17)
        public var rs485_frm_err: RS485_FRM_ERR

        /// Set this bit to clear the rs485_clash_int_raw interrupt.
        @WriteOnly(bits: 17..<18)
        public var rs485_clash: RS485_CLASH

        /// Set this bit to clear the at_cmd_char_det_int_raw interrupt.
        @WriteOnly(bits: 18..<19)
        public var at_cmd_char_det: AT_CMD_CHAR_DET

        /// Set this bit to clear the uart_wakeup_int_raw interrupt.
        @WriteOnly(bits: 19..<20)
        public var wakeup: WAKEUP
    }

    /// Clock divider configuration
    @Register(bitWidth: 32)
    public struct CLKDIV {
        /// The integral part of the frequency divider factor.
        @ReadWrite(bits: 0..<12)
        public var clkdiv_field: CLKDIV_FIELD

        /// The decimal part of the frequency divider factor.
        @ReadWrite(bits: 20..<24)
        public var frag: FRAG
    }

    /// Rx Filter configuration
    @Register(bitWidth: 32)
    public struct RX_FILT {
        /// when input pulse width is lower than this value the pulse is ignored.
        @ReadWrite(bits: 0..<8)
        public var glitch_filt: GLITCH_FILT

        /// Set this bit to enable Rx signal filter.
        @ReadWrite(bits: 8..<9)
        public var glitch_filt_en: GLITCH_FILT_EN
    }

    /// UART status register
    @Register(bitWidth: 32)
    public struct STATUS {
        /// Stores the byte number of valid data in Rx-FIFO.
        @ReadOnly(bits: 0..<8)
        public var rxfifo_cnt: RXFIFO_CNT

        /// The register represent the level value of the internal uart dsr signal.
        @ReadOnly(bits: 13..<14)
        public var dsrn: DSRN

        /// This register represent the level value of the internal uart cts signal.
        @ReadOnly(bits: 14..<15)
        public var ctsn: CTSN

        /// This register represent the level value of the internal uart rxd signal.
        @ReadOnly(bits: 15..<16)
        public var rxd: RXD

        /// Stores the byte number of data in Tx-FIFO.
        @ReadOnly(bits: 16..<24)
        public var txfifo_cnt: TXFIFO_CNT

        /// This bit represents the level of the internal uart dtr signal.
        @ReadOnly(bits: 29..<30)
        public var dtrn: DTRN

        /// This bit represents the level of the internal uart rts signal.
        @ReadOnly(bits: 30..<31)
        public var rtsn: RTSN

        /// This bit represents the level of the internal uart txd signal.
        @ReadOnly(bits: 31..<32)
        public var txd: TXD
    }

    /// a
    @Register(bitWidth: 32)
    public struct CONF0 {
        /// This register is used to configure the parity check mode.
        @ReadWrite(bits: 0..<1)
        public var parity: PARITY

        /// Set this bit to enable uart parity check.
        @ReadWrite(bits: 1..<2)
        public var parity_en: PARITY_EN

        /// This register is used to set the length of data.
        @ReadWrite(bits: 2..<4)
        public var bit_num: BIT_NUM

        /// This register is used to set the length of stop bit.
        @ReadWrite(bits: 4..<6)
        public var stop_bit_num: STOP_BIT_NUM

        /// Set this bit to enbale transmitter to send NULL when the process of sending data is done.
        @ReadWrite(bits: 6..<7)
        public var txd_brk: TXD_BRK

        /// Set this bit to enable IrDA loopback mode.
        @ReadWrite(bits: 7..<8)
        public var irda_dplx: IRDA_DPLX

        /// This is the start enable bit for IrDA transmitter.
        @ReadWrite(bits: 8..<9)
        public var irda_tx_en: IRDA_TX_EN

        /// 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit. 1'h0: Set IrDA transmitter's 11th bit to 0.
        @ReadWrite(bits: 9..<10)
        public var irda_wctl: IRDA_WCTL

        /// Set this bit to invert the level of IrDA transmitter.
        @ReadWrite(bits: 10..<11)
        public var irda_tx_inv: IRDA_TX_INV

        /// Set this bit to invert the level of IrDA receiver.
        @ReadWrite(bits: 11..<12)
        public var irda_rx_inv: IRDA_RX_INV

        /// Set this bit to enable uart loopback test mode.
        @ReadWrite(bits: 12..<13)
        public var loopback: LOOPBACK

        /// Set this bit to enable flow control function for transmitter.
        @ReadWrite(bits: 13..<14)
        public var tx_flow_en: TX_FLOW_EN

        /// Set this bit to enable IrDA protocol.
        @ReadWrite(bits: 14..<15)
        public var irda_en: IRDA_EN

        /// Set this bit to inverse the level value of uart rxd signal.
        @ReadWrite(bits: 15..<16)
        public var rxd_inv: RXD_INV

        /// Set this bit to inverse the level value of uart txd signal.
        @ReadWrite(bits: 16..<17)
        public var txd_inv: TXD_INV

        /// Disable UART Rx data overflow detect.
        @ReadWrite(bits: 17..<18)
        public var dis_rx_dat_ovf: DIS_RX_DAT_OVF

        /// 1'h1: Receiver stops storing data into FIFO when data is wrong. 1'h0: Receiver stores the data even if the received data is wrong.
        @ReadWrite(bits: 18..<19)
        public var err_wr_mask: ERR_WR_MASK

        /// This is the enable bit for detecting baudrate.
        @ReadWrite(bits: 19..<20)
        public var autobaud_en: AUTOBAUD_EN

        /// UART memory clock gate enable signal.
        @ReadWrite(bits: 20..<21)
        public var mem_clk_en: MEM_CLK_EN

        /// This register is used to configure the software rts signal which is used in software flow control.
        @ReadWrite(bits: 21..<22)
        public var sw_rts: SW_RTS

        /// Set this bit to reset the uart receive-FIFO.
        @ReadWrite(bits: 22..<23)
        public var rxfifo_rst: RXFIFO_RST

        /// Set this bit to reset the uart transmit-FIFO.
        @ReadWrite(bits: 23..<24)
        public var txfifo_rst: TXFIFO_RST
    }

    /// Configuration register 1
    @Register(bitWidth: 32)
    public struct CONF1 {
        /// It will produce rxfifo_full_int interrupt when receiver receives more data than this register value.
        @ReadWrite(bits: 0..<8)
        public var rxfifo_full_thrhd: RXFIFO_FULL_THRHD

        /// It will produce txfifo_empty_int interrupt when the data amount in Tx-FIFO is less than this register value.
        @ReadWrite(bits: 8..<16)
        public var txfifo_empty_thrhd: TXFIFO_EMPTY_THRHD

        /// Set this bit to inverse the level value of uart cts signal.
        @ReadWrite(bits: 16..<17)
        public var cts_inv: CTS_INV

        /// Set this bit to inverse the level value of uart dsr signal.
        @ReadWrite(bits: 17..<18)
        public var dsr_inv: DSR_INV

        /// Set this bit to inverse the level value of uart rts signal.
        @ReadWrite(bits: 18..<19)
        public var rts_inv: RTS_INV

        /// Set this bit to inverse the level value of uart dtr signal.
        @ReadWrite(bits: 19..<20)
        public var dtr_inv: DTR_INV

        /// This register is used to configure the software dtr signal which is used in software flow control.
        @ReadWrite(bits: 20..<21)
        public var sw_dtr: SW_DTR

        /// 1'h1: Force clock on for register. 1'h0: Support clock only when application writes registers.
        @ReadWrite(bits: 21..<22)
        public var clk_en: CLK_EN
    }

    /// Hardware flow-control configuration
    @Register(bitWidth: 32)
    public struct HWFC_CONF {
        /// This register is used to configure the maximum amount of data that can be received when hardware flow control works.
        @ReadWrite(bits: 0..<8)
        public var rx_flow_thrhd: RX_FLOW_THRHD

        /// This is the flow enable bit for UART receiver.
        @ReadWrite(bits: 8..<9)
        public var rx_flow_en: RX_FLOW_EN
    }

    /// UART sleep configure register 0
    @Register(bitWidth: 32)
    public struct SLEEP_CONF0 {
        /// This register restores the specified wake up char1 to wake up
        @ReadWrite(bits: 0..<8)
        public var wk_char1: WK_CHAR1

        /// This register restores the specified wake up char2 to wake up
        @ReadWrite(bits: 8..<16)
        public var wk_char2: WK_CHAR2

        /// This register restores the specified wake up char3 to wake up
        @ReadWrite(bits: 16..<24)
        public var wk_char3: WK_CHAR3

        /// This register restores the specified wake up char4 to wake up
        @ReadWrite(bits: 24..<32)
        public var wk_char4: WK_CHAR4
    }

    /// UART sleep configure register 1
    @Register(bitWidth: 32)
    public struct SLEEP_CONF1 {
        /// This register restores the specified char0 to wake up
        @ReadWrite(bits: 0..<8)
        public var wk_char0: WK_CHAR0
    }

    /// UART sleep configure register 2
    @Register(bitWidth: 32)
    public struct SLEEP_CONF2 {
        /// The uart is activated from light sleeping mode when the input rxd edge changes more times than this register value.
        @ReadWrite(bits: 0..<10)
        public var active_threshold: ACTIVE_THRESHOLD

        /// In wake up mode 1 this field is used to set the received data number threshold to wake up chip.
        @ReadWrite(bits: 10..<18)
        public var rx_wake_up_thrhd: RX_WAKE_UP_THRHD

        /// This register is used to select number of wake up char.
        @ReadWrite(bits: 18..<21)
        public var wk_char_num: WK_CHAR_NUM

        /// This register is used to mask wake up char.
        @ReadWrite(bits: 21..<26)
        public var wk_char_mask: WK_CHAR_MASK

        /// This register is used to select wake up mode. 0: RXD toggling to wake up. 1: received data number larger than
        @ReadWrite(bits: 26..<28)
        public var wk_mode_sel: WK_MODE_SEL
    }

    /// Software flow-control character configuration
    @Register(bitWidth: 32)
    public struct SWFC_CONF0 {
        /// This register stores the Xon flow control char.
        @ReadWrite(bits: 0..<8)
        public var xon_char: XON_CHAR

        /// This register stores the Xoff flow control char.
        @ReadWrite(bits: 8..<16)
        public var xoff_char: XOFF_CHAR

        /// In software flow control mode, UART Tx is disabled once UART Rx receives XOFF. In this status, UART Tx can not transmit XOFF even the received data number is larger than UART_XOFF_THRESHOLD. Set this bit to enable UART Tx can transmit XON/XOFF when UART Tx is disabled.
        @ReadWrite(bits: 16..<17)
        public var xon_xoff_still_send: XON_XOFF_STILL_SEND

        /// Set this bit to enable software flow control. It is used with register sw_xon or sw_xoff.
        @ReadWrite(bits: 17..<18)
        public var sw_flow_con_en: SW_FLOW_CON_EN

        /// Set this bit to remove flow control char from the received data.
        @ReadWrite(bits: 18..<19)
        public var xonoff_del: XONOFF_DEL

        /// Set this bit to enable the transmitter to go on sending data.
        @ReadWrite(bits: 19..<20)
        public var force_xon: FORCE_XON

        /// Set this bit to stop the transmitter from sending data.
        @ReadWrite(bits: 20..<21)
        public var force_xoff: FORCE_XOFF

        /// Set this bit to send Xon char. It is cleared by hardware automatically.
        @ReadWrite(bits: 21..<22)
        public var send_xon: SEND_XON

        /// Set this bit to send Xoff char. It is cleared by hardware automatically.
        @ReadWrite(bits: 22..<23)
        public var send_xoff: SEND_XOFF
    }

    /// Software flow-control character configuration
    @Register(bitWidth: 32)
    public struct SWFC_CONF1 {
        /// When the data amount in Rx-FIFO is less than this register value with uart_sw_flow_con_en set to 1 it will send a Xon char.
        @ReadWrite(bits: 0..<8)
        public var xon_threshold: XON_THRESHOLD

        /// When the data amount in Rx-FIFO is more than this register value with uart_sw_flow_con_en set to 1 it will send a Xoff char.
        @ReadWrite(bits: 8..<16)
        public var xoff_threshold: XOFF_THRESHOLD
    }

    /// Tx Break character configuration
    @Register(bitWidth: 32)
    public struct TXBRK_CONF {
        /// This register is used to configure the number of 0 to be sent after the process of sending data is done. It is active when txd_brk is set to 1.
        @ReadWrite(bits: 0..<8)
        public var tx_brk_num: TX_BRK_NUM
    }

    /// Frame-end idle configuration
    @Register(bitWidth: 32)
    public struct IDLE_CONF {
        /// It will produce frame end signal when receiver takes more time to receive one byte data than this register value.
        @ReadWrite(bits: 0..<10)
        public var rx_idle_thrhd: RX_IDLE_THRHD

        /// This register is used to configure the duration time between transfers.
        @ReadWrite(bits: 10..<20)
        public var tx_idle_num: TX_IDLE_NUM
    }

    /// RS485 mode configuration
    @Register(bitWidth: 32)
    public struct RS485_CONF {
        /// Set this bit to choose the rs485 mode.
        @ReadWrite(bits: 0..<1)
        public var rs485_en: RS485_EN

        /// Set this bit to delay the stop bit by 1 bit.
        @ReadWrite(bits: 1..<2)
        public var dl0_en: DL0_EN

        /// Set this bit to delay the stop bit by 1 bit.
        @ReadWrite(bits: 2..<3)
        public var dl1_en: DL1_EN

        /// Set this bit to enable receiver could receive data when the transmitter is transmitting data in rs485 mode.
        @ReadWrite(bits: 3..<4)
        public var rs485tx_rx_en: RS485TX_RX_EN

        /// 1'h1: enable rs485 transmitter to send data when rs485 receiver line is busy.
        @ReadWrite(bits: 4..<5)
        public var rs485rxby_tx_en: RS485RXBY_TX_EN

        /// This register is used to delay the receiver's internal data signal.
        @ReadWrite(bits: 5..<6)
        public var rs485_rx_dly_num: RS485_RX_DLY_NUM

        /// This register is used to delay the transmitter's internal data signal.
        @ReadWrite(bits: 6..<10)
        public var rs485_tx_dly_num: RS485_TX_DLY_NUM
    }

    /// Pre-sequence timing configuration
    @Register(bitWidth: 32)
    public struct AT_CMD_PRECNT {
        /// This register is used to configure the idle duration time before the first at_cmd is received by receiver.
        @ReadWrite(bits: 0..<16)
        public var pre_idle_num: PRE_IDLE_NUM
    }

    /// Post-sequence timing configuration
    @Register(bitWidth: 32)
    public struct AT_CMD_POSTCNT {
        /// This register is used to configure the duration time between the last at_cmd and the next data.
        @ReadWrite(bits: 0..<16)
        public var post_idle_num: POST_IDLE_NUM
    }

    /// Timeout configuration
    @Register(bitWidth: 32)
    public struct AT_CMD_GAPTOUT {
        /// This register is used to configure the duration time between the at_cmd chars.
        @ReadWrite(bits: 0..<16)
        public var rx_gap_tout: RX_GAP_TOUT
    }

    /// AT escape sequence detection configuration
    @Register(bitWidth: 32)
    public struct AT_CMD_CHAR {
        /// This register is used to configure the content of at_cmd char.
        @ReadWrite(bits: 0..<8)
        public var at_cmd_char_field: AT_CMD_CHAR_FIELD

        /// This register is used to configure the num of continuous at_cmd chars received by receiver.
        @ReadWrite(bits: 8..<16)
        public var char_num: CHAR_NUM
    }

    /// UART memory power configuration
    @Register(bitWidth: 32)
    public struct MEM_CONF {
        /// Set this bit to force power down UART memory.
        @ReadWrite(bits: 25..<26)
        public var mem_force_pd: MEM_FORCE_PD

        /// Set this bit to force power up UART memory.
        @ReadWrite(bits: 26..<27)
        public var mem_force_pu: MEM_FORCE_PU
    }

    /// UART threshold and allocation configuration
    @Register(bitWidth: 32)
    public struct TOUT_CONF {
        /// This is the enble bit for uart receiver's timeout function.
        @ReadWrite(bits: 0..<1)
        public var rx_tout_en: RX_TOUT_EN

        /// Set this bit to stop accumulating idle_cnt when hardware flow control works.
        @ReadWrite(bits: 1..<2)
        public var rx_tout_flow_dis: RX_TOUT_FLOW_DIS

        /// This register is used to configure the threshold time that receiver takes to receive one byte. The rxfifo_tout_int interrupt will be trigger when the receiver takes more time to receive one byte with rx_tout_en set to 1.
        @ReadWrite(bits: 2..<12)
        public var rx_tout_thrhd: RX_TOUT_THRHD
    }

    /// Tx-SRAM write and read offset address.
    @Register(bitWidth: 32)
    public struct MEM_TX_STATUS {
        /// This register stores the offset write address in Tx-SRAM.
        @ReadOnly(bits: 0..<8)
        public var tx_sram_waddr: TX_SRAM_WADDR

        /// This register stores the offset read address in Tx-SRAM.
        @ReadOnly(bits: 9..<17)
        public var tx_sram_raddr: TX_SRAM_RADDR
    }

    /// Rx-SRAM write and read offset address.
    @Register(bitWidth: 32)
    public struct MEM_RX_STATUS {
        /// This register stores the offset read address in RX-SRAM.
        @ReadOnly(bits: 0..<8)
        public var rx_sram_raddr: RX_SRAM_RADDR

        /// This register stores the offset write address in Rx-SRAM.
        @ReadOnly(bits: 9..<17)
        public var rx_sram_waddr: RX_SRAM_WADDR
    }

    /// UART transmit and receive status.
    @Register(bitWidth: 32)
    public struct FSM_STATUS {
        /// This is the status register of receiver.
        @ReadOnly(bits: 0..<4)
        public var st_urx_out: ST_URX_OUT

        /// This is the status register of transmitter.
        @ReadOnly(bits: 4..<8)
        public var st_utx_out: ST_UTX_OUT
    }

    /// Autobaud high pulse register
    @Register(bitWidth: 32)
    public struct POSPULSE {
        /// This register stores the minimal input clock count between two positive edges. It is used in boudrate-detect process.
        @ReadOnly(bits: 0..<12)
        public var posedge_min_cnt: POSEDGE_MIN_CNT
    }

    /// Autobaud low pulse register
    @Register(bitWidth: 32)
    public struct NEGPULSE {
        /// This register stores the minimal input clock count between two negative edges. It is used in boudrate-detect process.
        @ReadOnly(bits: 0..<12)
        public var negedge_min_cnt: NEGEDGE_MIN_CNT
    }

    /// Autobaud minimum low pulse duration register
    @Register(bitWidth: 32)
    public struct LOWPULSE {
        /// This register stores the value of the minimum duration time of the low level pulse. It is used in baud rate-detect process.
        @ReadOnly(bits: 0..<12)
        public var min_cnt: MIN_CNT
    }

    /// Autobaud minimum high pulse duration register
    @Register(bitWidth: 32)
    public struct HIGHPULSE {
        /// This register stores the value of the maxinum duration time for the high level pulse. It is used in baud rate-detect process.
        @ReadOnly(bits: 0..<12)
        public var min_cnt: MIN_CNT
    }

    /// Autobaud edge change count register
    @Register(bitWidth: 32)
    public struct RXD_CNT {
        /// This register stores the count of rxd edge change. It is used in baud rate-detect process.
        @ReadOnly(bits: 0..<10)
        public var rxd_edge_cnt: RXD_EDGE_CNT
    }

    /// UART core clock configuration
    @Register(bitWidth: 32)
    public struct CLK_CONF {
        /// The denominator of the frequency divider factor.
        @ReadWrite(bits: 0..<6)
        public var sclk_div_b: SCLK_DIV_B

        /// The numerator of the frequency divider factor.
        @ReadWrite(bits: 6..<12)
        public var sclk_div_a: SCLK_DIV_A

        /// The integral part of the frequency divider factor.
        @ReadWrite(bits: 12..<20)
        public var sclk_div_num: SCLK_DIV_NUM

        /// UART clock source select. 1: 80Mhz. 2: 8Mhz. 3: XTAL.
        @ReadWrite(bits: 20..<22)
        public var sclk_sel: SCLK_SEL

        /// Set this bit to enable UART Tx/Rx clock.
        @ReadWrite(bits: 22..<23)
        public var sclk_en: SCLK_EN

        /// Write 1 then write 0 to this bit to reset UART Tx/Rx.
        @ReadWrite(bits: 23..<24)
        public var rst_core: RST_CORE

        /// Set this bit to enable UART Tx clock.
        @ReadWrite(bits: 24..<25)
        public var tx_sclk_en: TX_SCLK_EN

        /// Set this bit to enable UART Rx clock.
        @ReadWrite(bits: 25..<26)
        public var rx_sclk_en: RX_SCLK_EN

        /// Write 1 then write 0 to this bit to reset UART Tx.
        @ReadWrite(bits: 26..<27)
        public var tx_rst_core: TX_RST_CORE

        /// Write 1 then write 0 to this bit to reset UART Rx.
        @ReadWrite(bits: 27..<28)
        public var rx_rst_core: RX_RST_CORE
    }

    /// UART Version register
    @Register(bitWidth: 32)
    public struct DATE {
        /// This is the version register.
        @ReadWrite(bits: 0..<32)
        public var date_field: DATE_FIELD
    }

    /// UART AFIFO Status
    @Register(bitWidth: 32)
    public struct AFIFO_STATUS {
        /// Full signal of APB TX AFIFO.
        @ReadOnly(bits: 0..<1)
        public var tx_afifo_full: TX_AFIFO_FULL

        /// Empty signal of APB TX AFIFO.
        @ReadOnly(bits: 1..<2)
        public var tx_afifo_empty: TX_AFIFO_EMPTY

        /// Full signal of APB RX AFIFO.
        @ReadOnly(bits: 2..<3)
        public var rx_afifo_full: RX_AFIFO_FULL

        /// Empty signal of APB RX AFIFO.
        @ReadOnly(bits: 3..<4)
        public var rx_afifo_empty: RX_AFIFO_EMPTY
    }

    /// UART Registers Configuration Update register
    @Register(bitWidth: 32)
    public struct REG_UPDATE {
        /// Software write 1 would synchronize registers into UART Core clock domain and would be cleared by hardware after synchronization is done.
        @ReadWrite(bits: 0..<1)
        public var reg_update_field: REG_UPDATE_FIELD
    }

    /// UART ID register
    @Register(bitWidth: 32)
    public struct ID {
        /// This register is used to configure the uart_id.
        @ReadWrite(bits: 0..<32)
        public var id_field: ID_FIELD
    }
}
