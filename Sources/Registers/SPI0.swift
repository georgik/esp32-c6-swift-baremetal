// Generated by svd2swift.

import MMIO

/// SPI (Serial Peripheral Interface) Controller 0
@RegisterBlock
public struct SPI0 {
    /// SPI0 FSM status register
    @RegisterBlock(offset: 0x0)
    public var cmd: Register<CMD>

    /// SPI0 control register.
    @RegisterBlock(offset: 0x8)
    public var ctrl: Register<CTRL>

    /// SPI0 control1 register.
    @RegisterBlock(offset: 0xc)
    public var ctrl1: Register<CTRL1>

    /// SPI0 control2 register.
    @RegisterBlock(offset: 0x10)
    public var ctrl2: Register<CTRL2>

    /// SPI clock division control register.
    @RegisterBlock(offset: 0x14)
    public var clock: Register<CLOCK>

    /// SPI0 user register.
    @RegisterBlock(offset: 0x18)
    public var user: Register<USER>

    /// SPI0 user1 register.
    @RegisterBlock(offset: 0x1c)
    public var user1: Register<USER1>

    /// SPI0 user2 register.
    @RegisterBlock(offset: 0x20)
    public var user2: Register<USER2>

    /// SPI0 read control register.
    @RegisterBlock(offset: 0x2c)
    public var rd_status: Register<RD_STATUS>

    /// SPI0 misc register
    @RegisterBlock(offset: 0x34)
    public var misc: Register<MISC>

    /// SPI0 bit mode control register.
    @RegisterBlock(offset: 0x3c)
    public var cache_fctrl: Register<CACHE_FCTRL>

    /// SPI0 external RAM control register
    @RegisterBlock(offset: 0x40)
    public var cache_sctrl: Register<CACHE_SCTRL>

    /// SPI0 external RAM mode control register
    @RegisterBlock(offset: 0x44)
    public var sram_cmd: Register<SRAM_CMD>

    /// SPI0 external RAM DDR read command control register
    @RegisterBlock(offset: 0x48)
    public var sram_drd_cmd: Register<SRAM_DRD_CMD>

    /// SPI0 external RAM DDR write command control register
    @RegisterBlock(offset: 0x4c)
    public var sram_dwr_cmd: Register<SRAM_DWR_CMD>

    /// SPI0 external RAM clock control register
    @RegisterBlock(offset: 0x50)
    public var sram_clk: Register<SRAM_CLK>

    /// SPI0 FSM status register
    @RegisterBlock(offset: 0x54)
    public var fsm: Register<FSM>

    /// SPI0 interrupt enable register
    @RegisterBlock(offset: 0xc0)
    public var int_ena: Register<INT_ENA>

    /// SPI0 interrupt clear register
    @RegisterBlock(offset: 0xc4)
    public var int_clr: Register<INT_CLR>

    /// SPI0 interrupt raw register
    @RegisterBlock(offset: 0xc8)
    public var int_raw: Register<INT_RAW>

    /// SPI0 interrupt status register
    @RegisterBlock(offset: 0xcc)
    public var int_st: Register<INT_ST>

    /// SPI0 flash DDR mode control register
    @RegisterBlock(offset: 0xd4)
    public var ddr: Register<DDR>

    /// SPI0 external RAM DDR mode control register
    @RegisterBlock(offset: 0xd8)
    public var spi_smem_ddr: Register<SPI_SMEM_DDR>

    /// MSPI flash ACE section %s attribute register
    @RegisterBlock(offset: 0x100, stride: 0x4, count: 4)
    public var spi_fmem_pms_attr: RegisterArray<SPI_FMEM_PMS_ATTR>

    /// SPI1 flash ACE section %s start address register
    @RegisterBlock(offset: 0x110, stride: 0x4, count: 4)
    public var spi_fmem_pms_addr: RegisterArray<SPI_FMEM_PMS_ADDR>

    /// SPI1 flash ACE section %s start address register
    @RegisterBlock(offset: 0x120, stride: 0x4, count: 4)
    public var spi_fmem_pms_size: RegisterArray<SPI_FMEM_PMS_SIZE>

    /// SPI1 flash ACE section %s start address register
    @RegisterBlock(offset: 0x130, stride: 0x4, count: 4)
    public var spi_smem_pms_attr: RegisterArray<SPI_SMEM_PMS_ATTR>

    /// SPI1 external RAM ACE section %s start address register
    @RegisterBlock(offset: 0x140, stride: 0x4, count: 4)
    public var spi_smem_pms_addr: RegisterArray<SPI_SMEM_PMS_ADDR>

    /// SPI1 external RAM ACE section %s start address register
    @RegisterBlock(offset: 0x150, stride: 0x4, count: 4)
    public var spi_smem_pms_size: RegisterArray<SPI_SMEM_PMS_SIZE>

    /// SPI1 access reject register
    @RegisterBlock(offset: 0x164)
    public var pms_reject: Register<PMS_REJECT>

    /// MSPI ECC control register
    @RegisterBlock(offset: 0x168)
    public var ecc_ctrl: Register<ECC_CTRL>

    /// MSPI ECC error address register
    @RegisterBlock(offset: 0x16c)
    public var ecc_err_addr: Register<ECC_ERR_ADDR>

    /// SPI0 AXI request error address.
    @RegisterBlock(offset: 0x170)
    public var axi_err_addr: Register<AXI_ERR_ADDR>

    /// MSPI ECC control register
    @RegisterBlock(offset: 0x174)
    public var spi_smem_ecc_ctrl: Register<SPI_SMEM_ECC_CTRL>

    /// SPI0 flash timing calibration register
    @RegisterBlock(offset: 0x180)
    public var timing_cali: Register<TIMING_CALI>

    /// MSPI flash input timing delay mode control register
    @RegisterBlock(offset: 0x184)
    public var din_mode: Register<DIN_MODE>

    /// MSPI flash input timing delay number control register
    @RegisterBlock(offset: 0x188)
    public var din_num: Register<DIN_NUM>

    /// MSPI flash output timing adjustment control register
    @RegisterBlock(offset: 0x18c)
    public var dout_mode: Register<DOUT_MODE>

    /// MSPI external RAM timing calibration register
    @RegisterBlock(offset: 0x190)
    public var spi_smem_timing_cali: Register<SPI_SMEM_TIMING_CALI>

    /// MSPI external RAM input timing delay mode control register
    @RegisterBlock(offset: 0x194)
    public var spi_smem_din_mode: Register<SPI_SMEM_DIN_MODE>

    /// MSPI external RAM input timing delay number control register
    @RegisterBlock(offset: 0x198)
    public var spi_smem_din_num: Register<SPI_SMEM_DIN_NUM>

    /// MSPI external RAM output timing adjustment control register
    @RegisterBlock(offset: 0x19c)
    public var spi_smem_dout_mode: Register<SPI_SMEM_DOUT_MODE>

    /// MSPI external RAM ECC and SPI CS timing control register
    @RegisterBlock(offset: 0x1a0)
    public var spi_smem_ac: Register<SPI_SMEM_AC>

    /// SPI0 clock gate register
    @RegisterBlock(offset: 0x200)
    public var clock_gate: Register<CLOCK_GATE>

    /// The base address of the memory that stores plaintext in Manual Encryption
    @RegisterBlock(offset: 0x300)
    public var xts_plain_base: Register<XTS_PLAIN_BASE>

    /// Manual Encryption Line-Size register
    @RegisterBlock(offset: 0x340)
    public var xts_linesize: Register<XTS_LINESIZE>

    /// Manual Encryption destination register
    @RegisterBlock(offset: 0x344)
    public var xts_destination: Register<XTS_DESTINATION>

    /// Manual Encryption physical address register
    @RegisterBlock(offset: 0x348)
    public var xts_physical_address: Register<XTS_PHYSICAL_ADDRESS>

    /// Manual Encryption physical address register
    @RegisterBlock(offset: 0x34c)
    public var xts_trigger: Register<XTS_TRIGGER>

    /// Manual Encryption physical address register
    @RegisterBlock(offset: 0x350)
    public var xts_release: Register<XTS_RELEASE>

    /// Manual Encryption physical address register
    @RegisterBlock(offset: 0x354)
    public var xts_destroy: Register<XTS_DESTROY>

    /// Manual Encryption physical address register
    @RegisterBlock(offset: 0x358)
    public var xts_state: Register<XTS_STATE>

    /// Manual Encryption version register
    @RegisterBlock(offset: 0x35c)
    public var xts_date: Register<XTS_DATE>

    /// MSPI-MMU item content register
    @RegisterBlock(offset: 0x37c)
    public var mmu_item_content: Register<MMU_ITEM_CONTENT>

    /// MSPI-MMU item index register
    @RegisterBlock(offset: 0x380)
    public var mmu_item_index: Register<MMU_ITEM_INDEX>

    /// MSPI MMU power control register
    @RegisterBlock(offset: 0x384)
    public var mmu_power_ctrl: Register<MMU_POWER_CTRL>

    /// SPI memory cryption DPA register
    @RegisterBlock(offset: 0x388)
    public var dpa_ctrl: Register<DPA_CTRL>

    /// MSPI ECO high register
    @RegisterBlock(offset: 0x3f0)
    public var registerrnd_eco_high: Register<REGISTERRND_ECO_HIGH>

    /// MSPI ECO low register
    @RegisterBlock(offset: 0x3f4)
    public var registerrnd_eco_low: Register<REGISTERRND_ECO_LOW>

    /// SPI0 version control register
    @RegisterBlock(offset: 0x3fc)
    public var date: Register<DATE>
}

extension SPI0 {
    /// SPI0 FSM status register
    @Register(bitWidth: 32)
    public struct CMD {
        /// The current status of SPI0 master FSM: spi0_mst_st. 0: idle state, 1:SPI0_GRANT , 2: program/erase suspend state, 3: SPI0 read data state, 4: wait cache/EDMA sent data is stored in SPI0 TX FIFO, 5: SPI0 write data state.
        @ReadOnly(bits: 0..<4)
        public var mst_st: MST_ST

        /// The current status of SPI0 slave FSM: mspi_st. 0: idle state, 1: preparation state, 2: send command state, 3: send address state, 4: wait state, 5: read data state, 6:write data state, 7: done state, 8: read data end state.
        @ReadOnly(bits: 4..<8)
        public var slv_st: SLV_ST

        /// SPI0 USR_CMD start bit, only used when SPI_MEM_AXI_REQ_EN is cleared. An operation will be triggered when the bit is set. The bit will be cleared once the operation done.1: enable 0: disable.
        @ReadOnly(bits: 18..<19)
        public var usr: USR
    }

    /// SPI0 control register.
    @Register(bitWidth: 32)
    public struct CTRL {
        /// In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_DQS is output by the MSPI controller.
        @ReadOnly(bits: 0..<1)
        public var wdummy_dqs_always_out: WDUMMY_DQS_ALWAYS_OUT

        /// In the dummy phase of an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller.
        @ReadWrite(bits: 1..<2)
        public var wdummy_always_out: WDUMMY_ALWAYS_OUT

        /// In an MSPI read data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the first half part of dummy phase. It is used to mask invalid SPI_DQS in the half part of dummy phase.
        @ReadWrite(bits: 2..<3)
        public var fdummy_rin: FDUMMY_RIN

        /// In an MSPI write data transfer when accesses to flash, the level of SPI_IO[7:0] is output by the MSPI controller in the second half part of dummy phase. It is used to pre-drive flash.
        @ReadWrite(bits: 3..<4)
        public var fdummy_wout: FDUMMY_WOUT

        /// Apply 8 signals during write-data phase 1:enable 0: disable
        @ReadOnly(bits: 4..<5)
        public var fdout_oct: FDOUT_OCT

        /// Apply 8 signals during read-data phase 1:enable 0: disable
        @ReadOnly(bits: 5..<6)
        public var fdin_oct: FDIN_OCT

        /// Apply 8 signals during address phase 1:enable 0: disable
        @ReadOnly(bits: 6..<7)
        public var faddr_oct: FADDR_OCT

        /// Apply 4 signals during command phase 1:enable 0: disable
        @ReadWrite(bits: 8..<9)
        public var fcmd_quad: FCMD_QUAD

        /// Apply 8 signals during command phase 1:enable 0: disable
        @ReadOnly(bits: 9..<10)
        public var fcmd_oct: FCMD_OCT

        /// This bit enable the bits: SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QOUT and SPI_MEM_FREAD_DOUT. 1: enable 0: disable.
        @ReadWrite(bits: 13..<14)
        public var fastrd_mode: FASTRD_MODE

        /// In the read operations, read-data phase apply 2 signals. 1: enable 0: disable.
        @ReadWrite(bits: 14..<15)
        public var fread_dual: FREAD_DUAL

        /// The bit is used to set MISO line polarity, 1: high 0, low
        @ReadWrite(bits: 18..<19)
        public var q_pol: Q_POL

        /// The bit is used to set MOSI line polarity, 1: high 0, low
        @ReadWrite(bits: 19..<20)
        public var d_pol: D_POL

        /// In the read operations read-data phase apply 4 signals. 1: enable 0: disable.
        @ReadWrite(bits: 20..<21)
        public var fread_quad: FREAD_QUAD

        /// Write protect signal output when SPI is idle. 1: output high, 0: output low.
        @ReadWrite(bits: 21..<22)
        public var wp: WP

        /// In the read operations address phase and read-data phase apply 2 signals. 1: enable 0: disable.
        @ReadWrite(bits: 23..<24)
        public var fread_dio: FREAD_DIO

        /// In the read operations address phase and read-data phase apply 4 signals. 1: enable 0: disable.
        @ReadWrite(bits: 24..<25)
        public var fread_qio: FREAD_QIO

        /// When accesses to flash, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
        @ReadOnly(bits: 30..<31)
        public var dqs_ie_always_on: DQS_IE_ALWAYS_ON

        /// When accesses to flash, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
        @ReadWrite(bits: 31..<32)
        public var data_ie_always_on: DATA_IE_ALWAYS_ON
    }

    /// SPI0 control1 register.
    @Register(bitWidth: 32)
    public struct CTRL1 {
        /// SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is alwasy on.
        @ReadWrite(bits: 0..<2)
        public var clk_mode: CLK_MODE

        /// 1: MSPI supports ARSIZE 0~3. When ARSIZE =0~2, MSPI read address is 4*n and reply the real AXI read data back. 0: When ARSIZE 0~1, MSPI reply SLV_ERR.
        @ReadWrite(bits: 21..<22)
        public var spi_ar_size0_1_support_en: SPI_AR_SIZE0_1_SUPPORT_EN

        /// 1: MSPI supports AWSIZE 0~3. 0: When AWSIZE 0~1, MSPI reply SLV_ERR.
        @ReadWrite(bits: 22..<23)
        public var spi_aw_size0_1_support_en: SPI_AW_SIZE0_1_SUPPORT_EN

        /// 1: Reply AXI read data to AXI bus when one AXI read beat data is available. 0: Reply AXI read data to AXI bus when all the read data is available.
        @ReadOnly(bits: 23..<24)
        public var spi_axi_rdata_back_fast: SPI_AXI_RDATA_BACK_FAST

        /// 1: RRESP is SLV_ERR when there is a ECC error in AXI read data. 0: RRESP is OKAY when there is a ECC error in AXI read data. The ECC error information is recorded in SPI_MEM_ECC_ERR_ADDR_REG.
        @ReadWrite(bits: 24..<25)
        public var rresp_ecc_err_en: RRESP_ECC_ERR_EN

        /// Set this bit to enable AXI Read Splice-transfer.
        @ReadOnly(bits: 25..<26)
        public var ar_splice_en: AR_SPLICE_EN

        /// Set this bit to enable AXI Write Splice-transfer.
        @ReadOnly(bits: 26..<27)
        public var aw_splice_en: AW_SPLICE_EN

        /// When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 1, only EXT_RAM0 will be accessed. When SPI_MEM_DUAL_RAM_EN is 0 and SPI_MEM_RAM0_EN is 0, only EXT_RAM1 will be accessed. When SPI_MEM_DUAL_RAM_EN is 1, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
        @ReadOnly(bits: 27..<28)
        public var ram0_en: RAM0_EN

        /// Set this bit to enable DUAL-RAM mode, EXT_RAM0 and EXT_RAM1 will be accessed at the same time.
        @ReadOnly(bits: 28..<29)
        public var dual_ram_en: DUAL_RAM_EN

        /// Set this bit to write data faster, do not wait write data has been stored in tx_bus_fifo_l2. It will wait 4*T_clk_ctrl to insure the write data has been stored in tx_bus_fifo_l2.
        @ReadWrite(bits: 29..<30)
        public var fast_write_en: FAST_WRITE_EN

        /// The synchronous reset signal for SPI0 RX AFIFO and all the AES_MSPI SYNC FIFO to receive signals from AXI. Set this bit to reset these FIFO.
        @WriteOnly(bits: 30..<31)
        public var rxfifo_rst: RXFIFO_RST

        /// The synchronous reset signal for SPI0 TX AFIFO and all the AES_MSPI SYNC FIFO to send signals to AXI. Set this bit to reset these FIFO.
        @WriteOnly(bits: 31..<32)
        public var txfifo_rst: TXFIFO_RST
    }

    /// SPI0 control2 register.
    @Register(bitWidth: 32)
    public struct CTRL2 {
        /// (cycles-1) of prepare phase by SPI Bus clock, this bits are combined with SPI_MEM_CS_SETUP bit.
        @ReadWrite(bits: 0..<5)
        public var cs_setup_time: CS_SETUP_TIME

        /// SPI CS signal is delayed to inactive by SPI bus clock, this bits are combined with SPI_MEM_CS_HOLD bit.
        @ReadWrite(bits: 5..<10)
        public var cs_hold_time: CS_HOLD_TIME

        /// SPI_MEM_CS_HOLD_TIME + SPI_MEM_ECC_CS_HOLD_TIME is the SPI0 CS hold cycle in ECC mode when accessed flash.
        @ReadOnly(bits: 10..<13)
        public var ecc_cs_hold_time: ECC_CS_HOLD_TIME

        /// 1: SPI0 and SPI1 skip page corner when accesses flash. 0: Not skip page corner when accesses flash.
        @ReadOnly(bits: 13..<14)
        public var ecc_skip_page_corner: ECC_SKIP_PAGE_CORNER

        /// Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses flash.
        @ReadOnly(bits: 14..<15)
        public var ecc_16to18_byte_en: ECC_16TO18_BYTE_EN

        /// Set this bit to enable SPI0 split one AXI read flash transfer into two SPI transfers when one transfer will cross flash or EXT_RAM page corner, valid no matter whether there is an ECC region or not.
        @ReadOnly(bits: 24..<25)
        public var split_trans_en: SPLIT_TRANS_EN

        /// These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        @ReadWrite(bits: 25..<31)
        public var cs_hold_delay: CS_HOLD_DELAY

        /// The spi0_mst_st and spi0_slv_st will be reset.
        @WriteOnly(bits: 31..<32)
        public var sync_reset: SYNC_RESET
    }

    /// SPI clock division control register.
    @Register(bitWidth: 32)
    public struct CLOCK {
        /// In the master mode it must be equal to spi_mem_clkcnt_N.
        @ReadWrite(bits: 0..<8)
        public var clkcnt_l: CLKCNT_L

        /// In the master mode it must be floor((spi_mem_clkcnt_N+1)/2-1).
        @ReadWrite(bits: 8..<16)
        public var clkcnt_h: CLKCNT_H

        /// In the master mode it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        @ReadWrite(bits: 16..<24)
        public var clkcnt_n: CLKCNT_N

        /// 1: 1-division mode, the frequency of SPI bus clock equals to that of MSPI module clock.
        @ReadWrite(bits: 31..<32)
        public var clk_equ_sysclk: CLK_EQU_SYSCLK
    }

    /// SPI0 user register.
    @Register(bitWidth: 32)
    public struct USER {
        /// spi cs keep low when spi is in done phase. 1: enable 0: disable.
        @ReadWrite(bits: 6..<7)
        public var cs_hold: CS_HOLD

        /// spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        @ReadWrite(bits: 7..<8)
        public var cs_setup: CS_SETUP

        /// The bit combined with SPI_MEM_CK_IDLE_EDGE bit to control SPI clock mode 0~3.
        @ReadWrite(bits: 9..<10)
        public var ck_out_edge: CK_OUT_EDGE

        /// spi clock is disable in dummy phase when the bit is enable.
        @ReadWrite(bits: 26..<27)
        public var usr_dummy_idle: USR_DUMMY_IDLE

        /// This bit enable the dummy phase of an operation.
        @ReadWrite(bits: 29..<30)
        public var usr_dummy: USR_DUMMY
    }

    /// SPI0 user1 register.
    @Register(bitWidth: 32)
    public struct USER1 {
        /// The length in spi_mem_clk cycles of dummy phase. The register value shall be (cycle_num-1).
        @ReadWrite(bits: 0..<6)
        public var usr_dummy_cyclelen: USR_DUMMY_CYCLELEN

        /// SPI0 USR_CMD read or write data byte length -1
        @ReadOnly(bits: 6..<9)
        public var usr_dbytelen: USR_DBYTELEN

        /// The length in bits of address phase. The register value shall be (bit_num-1).
        @ReadWrite(bits: 26..<32)
        public var usr_addr_bitlen: USR_ADDR_BITLEN
    }

    /// SPI0 user2 register.
    @Register(bitWidth: 32)
    public struct USER2 {
        /// The value of command.
        @ReadWrite(bits: 0..<16)
        public var usr_command_value: USR_COMMAND_VALUE

        /// The length in bits of command phase. The register value shall be (bit_num-1)
        @ReadWrite(bits: 28..<32)
        public var usr_command_bitlen: USR_COMMAND_BITLEN
    }

    /// SPI0 read control register.
    @Register(bitWidth: 32)
    public struct RD_STATUS {
        /// Mode bits in the flash fast read mode it is combined with spi_mem_fastrd_mode bit.
        @ReadWrite(bits: 16..<24)
        public var wb_mode: WB_MODE
    }

    /// SPI0 misc register
    @Register(bitWidth: 32)
    public struct MISC {
        /// For SPI0, flash is connected to SUBPINs.
        @ReadOnly(bits: 7..<8)
        public var fsub_pin: FSUB_PIN

        /// For SPI0, sram is connected to SUBPINs.
        @ReadOnly(bits: 8..<9)
        public var ssub_pin: SSUB_PIN

        /// 1: SPI_CLK line is high when idle 0: spi clk line is low when idle
        @ReadWrite(bits: 9..<10)
        public var ck_idle_edge: CK_IDLE_EDGE

        /// SPI_CS line keep low when the bit is set.
        @ReadWrite(bits: 10..<11)
        public var cs_keep_active: CS_KEEP_ACTIVE
    }

    /// SPI0 bit mode control register.
    @Register(bitWidth: 32)
    public struct CACHE_FCTRL {
        /// For SPI0, AXI master access enable, 1: enable, 0:disable.
        @ReadWrite(bits: 0..<1)
        public var axi_req_en: AXI_REQ_EN

        /// For SPI0, cache read flash with 4 bytes address, 1: enable, 0:disable.
        @ReadWrite(bits: 1..<2)
        public var cache_usr_addr_4byte: CACHE_USR_ADDR_4BYTE

        /// For SPI0, cache read flash for user define command, 1: enable, 0:disable.
        @ReadWrite(bits: 2..<3)
        public var cache_flash_usr_cmd: CACHE_FLASH_USR_CMD

        /// For SPI0 flash, din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        @ReadWrite(bits: 3..<4)
        public var fdin_dual: FDIN_DUAL

        /// For SPI0 flash, dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        @ReadWrite(bits: 4..<5)
        public var fdout_dual: FDOUT_DUAL

        /// For SPI0 flash, address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_dio.
        @ReadWrite(bits: 5..<6)
        public var faddr_dual: FADDR_DUAL

        /// For SPI0 flash, din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        @ReadWrite(bits: 6..<7)
        public var fdin_quad: FDIN_QUAD

        /// For SPI0 flash, dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        @ReadWrite(bits: 7..<8)
        public var fdout_quad: FDOUT_QUAD

        /// For SPI0 flash, address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_fread_qio.
        @ReadWrite(bits: 8..<9)
        public var faddr_quad: FADDR_QUAD

        /// Set this bit to check AXI read/write the same address region.
        @ReadOnly(bits: 30..<31)
        public var spi_same_aw_ar_addr_chk_en: SPI_SAME_AW_AR_ADDR_CHK_EN

        /// Set this bit to close AXI read/write transfer to MSPI, which means that only SLV_ERR will be replied to BRESP/RRESP.
        @ReadWrite(bits: 31..<32)
        public var spi_close_axi_inf_en: SPI_CLOSE_AXI_INF_EN
    }

    /// SPI0 external RAM control register
    @Register(bitWidth: 32)
    public struct CACHE_SCTRL {
        /// For SPI0, In the external RAM mode, cache read flash with 4 bytes command, 1: enable, 0:disable.
        @ReadOnly(bits: 0..<1)
        public var cache_usr_saddr_4byte: CACHE_USR_SADDR_4BYTE

        /// For SPI0, In the external RAM mode, spi dual I/O mode enable, 1: enable, 0:disable
        @ReadOnly(bits: 1..<2)
        public var usr_sram_dio: USR_SRAM_DIO

        /// For SPI0, In the external RAM mode, spi quad I/O mode enable, 1: enable, 0:disable
        @ReadOnly(bits: 2..<3)
        public var usr_sram_qio: USR_SRAM_QIO

        /// For SPI0, In the external RAM mode, it is the enable bit of dummy phase for write operations.
        @ReadOnly(bits: 3..<4)
        public var usr_wr_sram_dummy: USR_WR_SRAM_DUMMY

        /// For SPI0, In the external RAM mode, it is the enable bit of dummy phase for read operations.
        @ReadOnly(bits: 4..<5)
        public var usr_rd_sram_dummy: USR_RD_SRAM_DUMMY

        /// For SPI0, In the external RAM mode cache read external RAM for user define command.
        @ReadOnly(bits: 5..<6)
        public var cache_sram_usr_rcmd: CACHE_SRAM_USR_RCMD

        /// For SPI0, In the external RAM mode, it is the length in bits of read dummy phase. The register value shall be (bit_num-1).
        @ReadOnly(bits: 6..<12)
        public var sram_rdummy_cyclelen: SRAM_RDUMMY_CYCLELEN

        /// For SPI0, In the external RAM mode, it is the length in bits of address phase. The register value shall be (bit_num-1).
        @ReadOnly(bits: 14..<20)
        public var sram_addr_bitlen: SRAM_ADDR_BITLEN

        /// For SPI0, In the external RAM mode cache write sram for user define command
        @ReadOnly(bits: 20..<21)
        public var cache_sram_usr_wcmd: CACHE_SRAM_USR_WCMD

        /// reserved
        @ReadOnly(bits: 21..<22)
        public var sram_oct: SRAM_OCT

        /// For SPI0, In the external RAM mode, it is the length in bits of write dummy phase. The register value shall be (bit_num-1).
        @ReadOnly(bits: 22..<28)
        public var sram_wdummy_cyclelen: SRAM_WDUMMY_CYCLELEN
    }

    /// SPI0 external RAM mode control register
    @Register(bitWidth: 32)
    public struct SRAM_CMD {
        /// SPI clock mode bits. 0: SPI clock is off when CS inactive 1: SPI clock is delayed one cycle after CS inactive 2: SPI clock is delayed two cycles after CS inactive 3: SPI clock is always on.
        @ReadOnly(bits: 0..<2)
        public var sclk_mode: SCLK_MODE

        /// Mode bits in the external RAM fast read mode it is combined with spi_mem_fastrd_mode bit.
        @ReadOnly(bits: 2..<10)
        public var swb_mode: SWB_MODE

        /// For SPI0 external RAM , din phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        @ReadOnly(bits: 10..<11)
        public var sdin_dual: SDIN_DUAL

        /// For SPI0 external RAM , dout phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        @ReadOnly(bits: 11..<12)
        public var sdout_dual: SDOUT_DUAL

        /// For SPI0 external RAM , address phase apply 2 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_dio.
        @ReadOnly(bits: 12..<13)
        public var saddr_dual: SADDR_DUAL

        /// For SPI0 external RAM , din phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        @ReadOnly(bits: 14..<15)
        public var sdin_quad: SDIN_QUAD

        /// For SPI0 external RAM , dout phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        @ReadOnly(bits: 15..<16)
        public var sdout_quad: SDOUT_QUAD

        /// For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        @ReadOnly(bits: 16..<17)
        public var saddr_quad: SADDR_QUAD

        /// For SPI0 external RAM , cmd phase apply 4 signals. 1: enable 0: disable. The bit is the same with spi_mem_usr_sram_qio.
        @ReadOnly(bits: 17..<18)
        public var scmd_quad: SCMD_QUAD

        /// For SPI0 external RAM , din phase apply 8 signals. 1: enable 0: disable.
        @ReadOnly(bits: 18..<19)
        public var sdin_oct: SDIN_OCT

        /// For SPI0 external RAM , dout phase apply 8 signals. 1: enable 0: disable.
        @ReadOnly(bits: 19..<20)
        public var sdout_oct: SDOUT_OCT

        /// For SPI0 external RAM , address phase apply 4 signals. 1: enable 0: disable.
        @ReadOnly(bits: 20..<21)
        public var saddr_oct: SADDR_OCT

        /// For SPI0 external RAM , cmd phase apply 8 signals. 1: enable 0: disable.
        @ReadOnly(bits: 21..<22)
        public var scmd_oct: SCMD_OCT

        /// In the dummy phase of a MSPI read data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
        @ReadWrite(bits: 22..<23)
        public var sdummy_rin: SDUMMY_RIN

        /// In the dummy phase of a MSPI write data transfer when accesses to external RAM, the signal level of SPI bus is output by the MSPI controller.
        @ReadOnly(bits: 23..<24)
        public var sdummy_wout: SDUMMY_WOUT

        /// In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_DQS is output by the MSPI controller.
        @ReadOnly(bits: 24..<25)
        public var spi_smem_wdummy_dqs_always_out: SPI_SMEM_WDUMMY_DQS_ALWAYS_OUT

        /// In the dummy phase of an MSPI write data transfer when accesses to external RAM, the level of SPI_IO[7:0] is output by the MSPI controller.
        @ReadOnly(bits: 25..<26)
        public var spi_smem_wdummy_always_out: SPI_SMEM_WDUMMY_ALWAYS_OUT

        /// When accesses to external RAM, 1: the IE signals of pads connected to SPI_DQS are always 1. 0: Others.
        @ReadOnly(bits: 30..<31)
        public var spi_smem_dqs_ie_always_on: SPI_SMEM_DQS_IE_ALWAYS_ON

        /// When accesses to external RAM, 1: the IE signals of pads connected to SPI_IO[7:0] are always 1. 0: Others.
        @ReadOnly(bits: 31..<32)
        public var spi_smem_data_ie_always_on: SPI_SMEM_DATA_IE_ALWAYS_ON
    }

    /// SPI0 external RAM DDR read command control register
    @Register(bitWidth: 32)
    public struct SRAM_DRD_CMD {
        /// For SPI0,When cache mode is enable it is the read command value of command phase for sram.
        @ReadOnly(bits: 0..<16)
        public var cache_sram_usr_rd_cmd_value: CACHE_SRAM_USR_RD_CMD_VALUE

        /// For SPI0,When cache mode is enable it is the length in bits of command phase for sram. The register value shall be (bit_num-1).
        @ReadOnly(bits: 28..<32)
        public var cache_sram_usr_rd_cmd_bitlen: CACHE_SRAM_USR_RD_CMD_BITLEN
    }

    /// SPI0 external RAM DDR write command control register
    @Register(bitWidth: 32)
    public struct SRAM_DWR_CMD {
        /// For SPI0,When cache mode is enable it is the write command value of command phase for sram.
        @ReadOnly(bits: 0..<16)
        public var cache_sram_usr_wr_cmd_value: CACHE_SRAM_USR_WR_CMD_VALUE

        /// For SPI0,When cache mode is enable it is the in bits of command phase for sram. The register value shall be (bit_num-1).
        @ReadOnly(bits: 28..<32)
        public var cache_sram_usr_wr_cmd_bitlen: CACHE_SRAM_USR_WR_CMD_BITLEN
    }

    /// SPI0 external RAM clock control register
    @Register(bitWidth: 32)
    public struct SRAM_CLK {
        /// For SPI0 external RAM interface, it must be equal to spi_mem_clkcnt_N.
        @ReadOnly(bits: 0..<8)
        public var sclkcnt_l: SCLKCNT_L

        /// For SPI0 external RAM interface, it must be floor((spi_mem_clkcnt_N+1)/2-1).
        @ReadOnly(bits: 8..<16)
        public var sclkcnt_h: SCLKCNT_H

        /// For SPI0 external RAM interface, it is the divider of spi_mem_clk. So spi_mem_clk frequency is system/(spi_mem_clkcnt_N+1)
        @ReadOnly(bits: 16..<24)
        public var sclkcnt_n: SCLKCNT_N

        /// For SPI0 external RAM interface, 1: spi_mem_clk is eqaul to system 0: spi_mem_clk is divided from system clock.
        @ReadOnly(bits: 31..<32)
        public var sclk_equ_sysclk: SCLK_EQU_SYSCLK
    }

    /// SPI0 FSM status register
    @Register(bitWidth: 32)
    public struct FSM {
        /// The lock delay time of SPI0/1 arbiter by spi0_slv_st, after PER is sent by SPI1.
        @ReadWrite(bits: 7..<12)
        public var lock_delay_time: LOCK_DELAY_TIME
    }

    /// SPI0 interrupt enable register
    @Register(bitWidth: 32)
    public struct INT_ENA {
        /// The enable bit for SPI_MEM_SLV_ST_END_INT interrupt.
        @ReadWrite(bits: 3..<4)
        public var slv_st_end: SLV_ST_END

        /// The enable bit for SPI_MEM_MST_ST_END_INT interrupt.
        @ReadWrite(bits: 4..<5)
        public var mst_st_end: MST_ST_END

        /// The enable bit for SPI_MEM_ECC_ERR_INT interrupt.
        @ReadOnly(bits: 5..<6)
        public var ecc_err: ECC_ERR

        /// The enable bit for SPI_MEM_PMS_REJECT_INT interrupt.
        @ReadWrite(bits: 6..<7)
        public var pms_reject: PMS_REJECT

        /// The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        @ReadWrite(bits: 7..<8)
        public var axi_raddr_err: AXI_RADDR_ERR

        /// The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        @ReadOnly(bits: 8..<9)
        public var axi_wr_flash_err: AXI_WR_FLASH_ERR

        /// The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
        @ReadOnly(bits: 9..<10)
        public var axi_waddr_err_int__ena: AXI_WADDR_ERR_INT__ENA
    }

    /// SPI0 interrupt clear register
    @Register(bitWidth: 32)
    public struct INT_CLR {
        /// The clear bit for SPI_MEM_SLV_ST_END_INT interrupt.
        @WriteOnly(bits: 3..<4)
        public var slv_st_end: SLV_ST_END

        /// The clear bit for SPI_MEM_MST_ST_END_INT interrupt.
        @WriteOnly(bits: 4..<5)
        public var mst_st_end: MST_ST_END

        /// The clear bit for SPI_MEM_ECC_ERR_INT interrupt.
        @ReadOnly(bits: 5..<6)
        public var ecc_err: ECC_ERR

        /// The clear bit for SPI_MEM_PMS_REJECT_INT interrupt.
        @WriteOnly(bits: 6..<7)
        public var pms_reject: PMS_REJECT

        /// The clear bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        @WriteOnly(bits: 7..<8)
        public var axi_raddr_err: AXI_RADDR_ERR

        /// The clear bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        @ReadOnly(bits: 8..<9)
        public var axi_wr_flash_err: AXI_WR_FLASH_ERR

        /// The clear bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
        @ReadOnly(bits: 9..<10)
        public var axi_waddr_err: AXI_WADDR_ERR
    }

    /// SPI0 interrupt raw register
    @Register(bitWidth: 32)
    public struct INT_RAW {
        /// The raw bit for SPI_MEM_SLV_ST_END_INT interrupt. 1: Triggered when spi0_slv_st is changed from non idle state to idle state. It means that SPI_CS raises high. 0: Others
        @ReadWrite(bits: 3..<4)
        public var slv_st_end: SLV_ST_END

        /// The raw bit for SPI_MEM_MST_ST_END_INT interrupt. 1: Triggered when spi0_mst_st is changed from non idle state to idle state. 0: Others.
        @ReadWrite(bits: 4..<5)
        public var mst_st_end: MST_ST_END

        /// The raw bit for SPI_MEM_ECC_ERR_INT interrupt. When SPI_FMEM_ECC_ERR_INT_EN is set and SPI_SMEM_ECC_ERR_INT_EN is cleared, this bit is triggered when the error times of SPI0/1 ECC read flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN is cleared and SPI_SMEM_ECC_ERR_INT_EN is set, this bit is triggered when the error times of SPI0/1 ECC read external RAM are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN and SPI_SMEM_ECC_ERR_INT_EN are set, this bit is triggered when the total error times of SPI0/1 ECC read external RAM and flash are equal or bigger than SPI_MEM_ECC_ERR_INT_NUM. When SPI_FMEM_ECC_ERR_INT_EN and SPI_SMEM_ECC_ERR_INT_EN are cleared, this bit will not be triggered.
        @ReadOnly(bits: 5..<6)
        public var ecc_err: ECC_ERR

        /// The raw bit for SPI_MEM_PMS_REJECT_INT interrupt. 1: Triggered when SPI1 access is rejected. 0: Others.
        @ReadWrite(bits: 6..<7)
        public var pms_reject: PMS_REJECT

        /// The raw bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt. 1: Triggered when AXI read address is invalid by compared to MMU configuration. 0: Others.
        @ReadWrite(bits: 7..<8)
        public var axi_raddr_err: AXI_RADDR_ERR

        /// The raw bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt. 1: Triggered when AXI write flash request is received. 0: Others.
        @ReadOnly(bits: 8..<9)
        public var axi_wr_flash_err: AXI_WR_FLASH_ERR

        /// The raw bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt. 1: Triggered when AXI write address is invalid by compared to MMU configuration. 0: Others.
        @ReadOnly(bits: 9..<10)
        public var axi_waddr_err: AXI_WADDR_ERR
    }

    /// SPI0 interrupt status register
    @Register(bitWidth: 32)
    public struct INT_ST {
        /// The status bit for SPI_MEM_SLV_ST_END_INT interrupt.
        @ReadOnly(bits: 3..<4)
        public var slv_st_end: SLV_ST_END

        /// The status bit for SPI_MEM_MST_ST_END_INT interrupt.
        @ReadOnly(bits: 4..<5)
        public var mst_st_end: MST_ST_END

        /// The status bit for SPI_MEM_ECC_ERR_INT interrupt.
        @ReadOnly(bits: 5..<6)
        public var ecc_err: ECC_ERR

        /// The status bit for SPI_MEM_PMS_REJECT_INT interrupt.
        @ReadOnly(bits: 6..<7)
        public var pms_reject: PMS_REJECT

        /// The enable bit for SPI_MEM_AXI_RADDR_ERR_INT interrupt.
        @ReadOnly(bits: 7..<8)
        public var axi_raddr_err: AXI_RADDR_ERR

        /// The enable bit for SPI_MEM_AXI_WR_FALSH_ERR_INT interrupt.
        @ReadOnly(bits: 8..<9)
        public var axi_wr_flash_err: AXI_WR_FLASH_ERR

        /// The enable bit for SPI_MEM_AXI_WADDR_ERR_INT interrupt.
        @ReadOnly(bits: 9..<10)
        public var axi_waddr_err: AXI_WADDR_ERR
    }

    /// SPI0 flash DDR mode control register
    @Register(bitWidth: 32)
    public struct DDR {
        /// 1: in DDR mode, 0 in SDR mode
        @ReadOnly(bits: 0..<1)
        public var spi_fmem_ddr_en: SPI_FMEM_DDR_EN

        /// Set the bit to enable variable dummy cycle in spi DDR mode.
        @ReadOnly(bits: 1..<2)
        public var spi_fmem_var_dummy: SPI_FMEM_VAR_DUMMY

        /// Set the bit to reorder rx data of the word in spi DDR mode.
        @ReadOnly(bits: 2..<3)
        public var spi_fmem_ddr_rdat_swp: SPI_FMEM_DDR_RDAT_SWP

        /// Set the bit to reorder tx data of the word in spi DDR mode.
        @ReadOnly(bits: 3..<4)
        public var spi_fmem_ddr_wdat_swp: SPI_FMEM_DDR_WDAT_SWP

        /// the bit is used to disable dual edge in command phase when DDR mode.
        @ReadOnly(bits: 4..<5)
        public var spi_fmem_ddr_cmd_dis: SPI_FMEM_DDR_CMD_DIS

        /// It is the minimum output data length in the panda device.
        @ReadOnly(bits: 5..<12)
        public var spi_fmem_outminbytelen: SPI_FMEM_OUTMINBYTELEN

        /// Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to flash.
        @ReadOnly(bits: 12..<13)
        public var spi_fmem_tx_ddr_msk_en: SPI_FMEM_TX_DDR_MSK_EN

        /// Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to flash.
        @ReadOnly(bits: 13..<14)
        public var spi_fmem_rx_ddr_msk_en: SPI_FMEM_RX_DDR_MSK_EN

        /// The delay number of data strobe which from memory based on SPI clock.
        @ReadOnly(bits: 14..<21)
        public var spi_fmem_usr_ddr_dqs_thd: SPI_FMEM_USR_DDR_DQS_THD

        /// 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
        @ReadOnly(bits: 21..<22)
        public var spi_fmem_ddr_dqs_loop: SPI_FMEM_DDR_DQS_LOOP

        /// Set this bit to enable the differential SPI_CLK#.
        @ReadOnly(bits: 24..<25)
        public var spi_fmem_clk_diff_en: SPI_FMEM_CLK_DIFF_EN

        /// Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        @ReadOnly(bits: 26..<27)
        public var spi_fmem_dqs_ca_in: SPI_FMEM_DQS_CA_IN

        /// Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
        @ReadOnly(bits: 27..<28)
        public var spi_fmem_hyperbus_dummy_2x: SPI_FMEM_HYPERBUS_DUMMY_2X

        /// Set this bit to invert SPI_DIFF when accesses to flash. .
        @ReadOnly(bits: 28..<29)
        public var spi_fmem_clk_diff_inv: SPI_FMEM_CLK_DIFF_INV

        /// Set this bit to enable octa_ram address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        @ReadOnly(bits: 29..<30)
        public var spi_fmem_octa_ram_addr: SPI_FMEM_OCTA_RAM_ADDR

        /// Set this bit to enable HyperRAM address out when accesses to flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
        @ReadOnly(bits: 30..<31)
        public var spi_fmem_hyperbus_ca: SPI_FMEM_HYPERBUS_CA
    }

    /// SPI0 external RAM DDR mode control register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_DDR {
        /// 1: in DDR mode, 0 in SDR mode
        @ReadOnly(bits: 0..<1)
        public var en: EN

        /// Set the bit to enable variable dummy cycle in spi DDR mode.
        @ReadOnly(bits: 1..<2)
        public var spi_smem_var_dummy: SPI_SMEM_VAR_DUMMY

        /// Set the bit to reorder rx data of the word in spi DDR mode.
        @ReadOnly(bits: 2..<3)
        public var rdat_swp: RDAT_SWP

        /// Set the bit to reorder tx data of the word in spi DDR mode.
        @ReadOnly(bits: 3..<4)
        public var wdat_swp: WDAT_SWP

        /// the bit is used to disable dual edge in command phase when DDR mode.
        @ReadOnly(bits: 4..<5)
        public var cmd_dis: CMD_DIS

        /// It is the minimum output data length in the DDR psram.
        @ReadOnly(bits: 5..<12)
        public var spi_smem_outminbytelen: SPI_SMEM_OUTMINBYTELEN

        /// Set this bit to mask the first or the last byte in SPI0 ECC DDR write mode, when accesses to external RAM.
        @ReadOnly(bits: 12..<13)
        public var spi_smem_tx_ddr_msk_en: SPI_SMEM_TX_DDR_MSK_EN

        /// Set this bit to mask the first or the last byte in SPI0 ECC DDR read mode, when accesses to external RAM.
        @ReadOnly(bits: 13..<14)
        public var spi_smem_rx_ddr_msk_en: SPI_SMEM_RX_DDR_MSK_EN

        /// The delay number of data strobe which from memory based on SPI clock.
        @ReadOnly(bits: 14..<21)
        public var spi_smem_usr_ddr_dqs_thd: SPI_SMEM_USR_DDR_DQS_THD

        /// 1: Do not need the input of SPI_DQS signal, SPI0 starts to receive data when spi0_slv_st is in SPI_MEM_DIN state. It is used when there is no SPI_DQS signal or SPI_DQS signal is not stable. 0: SPI0 starts to store data at the positive and negative edge of SPI_DQS.
        @ReadOnly(bits: 21..<22)
        public var dqs_loop: DQS_LOOP

        /// Set this bit to enable the differential SPI_CLK#.
        @ReadOnly(bits: 24..<25)
        public var spi_smem_clk_diff_en: SPI_SMEM_CLK_DIFF_EN

        /// Set this bit to enable the input of SPI_DQS signal in SPI phases of CMD and ADDR.
        @ReadOnly(bits: 26..<27)
        public var spi_smem_dqs_ca_in: SPI_SMEM_DQS_CA_IN

        /// Set this bit to enable the vary dummy function in SPI HyperBus mode, when SPI0 accesses flash or SPI1 accesses flash or sram.
        @ReadOnly(bits: 27..<28)
        public var spi_smem_hyperbus_dummy_2x: SPI_SMEM_HYPERBUS_DUMMY_2X

        /// Set this bit to invert SPI_DIFF when accesses to external RAM. .
        @ReadOnly(bits: 28..<29)
        public var spi_smem_clk_diff_inv: SPI_SMEM_CLK_DIFF_INV

        /// Set this bit to enable octa_ram address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4], 6'd0, spi_usr_addr_value[3:1], 1'b0}.
        @ReadOnly(bits: 29..<30)
        public var spi_smem_octa_ram_addr: SPI_SMEM_OCTA_RAM_ADDR

        /// Set this bit to enable HyperRAM address out when accesses to external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4], 13'd0, spi_usr_addr_value[3:1]}.
        @ReadOnly(bits: 30..<31)
        public var spi_smem_hyperbus_ca: SPI_SMEM_HYPERBUS_CA
    }

    /// MSPI flash ACE section %s attribute register
    @Register(bitWidth: 32)
    public struct SPI_FMEM_PMS_ATTR {
        /// 1: SPI1 flash ACE section %s read accessible. 0: Not allowed.
        @ReadWrite(bits: 0..<1)
        public var spi_fmem_pms_rd_attr: SPI_FMEM_PMS_RD_ATTR

        /// 1: SPI1 flash ACE section %s write accessible. 0: Not allowed.
        @ReadWrite(bits: 1..<2)
        public var spi_fmem_pms_wr_attr: SPI_FMEM_PMS_WR_ATTR

        /// SPI1 flash ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The flash ACE section %s is configured by registers SPI_FMEM_PMS%s_ADDR_REG and SPI_FMEM_PMS%s_SIZE_REG.
        @ReadWrite(bits: 2..<3)
        public var spi_fmem_pms_ecc: SPI_FMEM_PMS_ECC
    }

    /// SPI1 flash ACE section %s start address register
    @Register(bitWidth: 32)
    public struct SPI_FMEM_PMS_ADDR {
        /// SPI1 flash ACE section %s start address value
        @ReadWrite(bits: 0..<26)
        public var s: S
    }

    /// SPI1 flash ACE section %s start address register
    @Register(bitWidth: 32)
    public struct SPI_FMEM_PMS_SIZE {
        /// SPI1 flash ACE section %s address region is (SPI_FMEM_PMS%s_ADDR_S, SPI_FMEM_PMS%s_ADDR_S + SPI_FMEM_PMS%s_SIZE)
        @ReadWrite(bits: 0..<14)
        public var spi_fmem_pms_size_field: SPI_FMEM_PMS_SIZE_FIELD
    }

    /// SPI1 flash ACE section %s start address register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_PMS_ATTR {
        /// 1: SPI1 external RAM ACE section %s read accessible. 0: Not allowed.
        @ReadWrite(bits: 0..<1)
        public var spi_smem_pms_rd_attr: SPI_SMEM_PMS_RD_ATTR

        /// 1: SPI1 external RAM ACE section %s write accessible. 0: Not allowed.
        @ReadWrite(bits: 1..<2)
        public var spi_smem_pms_wr_attr: SPI_SMEM_PMS_WR_ATTR

        /// SPI1 external RAM ACE section %s ECC mode, 1: enable ECC mode. 0: Disable it. The external RAM ACE section %s is configured by registers SPI_SMEM_PMS%s_ADDR_REG and SPI_SMEM_PMS%s_SIZE_REG.
        @ReadWrite(bits: 2..<3)
        public var spi_smem_pms_ecc: SPI_SMEM_PMS_ECC
    }

    /// SPI1 external RAM ACE section %s start address register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_PMS_ADDR {
        /// SPI1 external RAM ACE section %s start address value
        @ReadWrite(bits: 0..<26)
        public var s: S
    }

    /// SPI1 external RAM ACE section %s start address register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_PMS_SIZE {
        /// SPI1 external RAM ACE section %s address region is (SPI_SMEM_PMS%s_ADDR_S, SPI_SMEM_PMS%s_ADDR_S + SPI_SMEM_PMS%s_SIZE)
        @ReadWrite(bits: 0..<14)
        public var spi_smem_pms_size_field: SPI_SMEM_PMS_SIZE_FIELD
    }

    /// SPI1 access reject register
    @Register(bitWidth: 32)
    public struct PMS_REJECT {
        /// This bits show the first SPI1 access error address. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        @ReadOnly(bits: 0..<26)
        public var reject_addr: REJECT_ADDR

        /// Set this bit to enable SPI0/1 transfer permission control function.
        @ReadWrite(bits: 26..<27)
        public var pm_en: PM_EN

        /// 1: SPI1 write access error. 0: No write access error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        @ReadOnly(bits: 28..<29)
        public var pms_ld: PMS_LD

        /// 1: SPI1 read access error. 0: No read access error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        @ReadOnly(bits: 29..<30)
        public var pms_st: PMS_ST

        /// 1: SPI1 access is rejected because of address miss. 0: No address miss error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        @ReadOnly(bits: 30..<31)
        public var pms_multi_hit: PMS_MULTI_HIT

        /// 1: SPI1 access is rejected because of address multi-hit. 0: No address multi-hit error. It is cleared by when SPI_MEM_PMS_REJECT_INT_CLR bit is set.
        @ReadOnly(bits: 31..<32)
        public var pms_ivd: PMS_IVD
    }

    /// MSPI ECC control register
    @Register(bitWidth: 32)
    public struct ECC_CTRL {
        /// Set the error times of MSPI ECC read to generate MSPI SPI_MEM_ECC_ERR_INT interrupt.
        @ReadOnly(bits: 11..<17)
        public var spi_fmem_ecc_err_int_num: SPI_FMEM_ECC_ERR_INT_NUM

        /// Set this bit to calculate the error times of MSPI ECC read when accesses to flash.
        @ReadOnly(bits: 17..<18)
        public var spi_fmem_ecc_err_int_en: SPI_FMEM_ECC_ERR_INT_EN

        /// Set the page size of the flash accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
        @ReadWrite(bits: 18..<20)
        public var spi_fmem_page_size: SPI_FMEM_PAGE_SIZE

        /// Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of flash. If there is no ECC region in flash, this bit should be 0. Otherwise, this bit should be 1.
        @ReadOnly(bits: 20..<21)
        public var spi_fmem_ecc_addr_en: SPI_FMEM_ECC_ADDR_EN

        /// Set this bit to enable ECC address convert in SPI0/1 USR_CMD transfer.
        @ReadOnly(bits: 21..<22)
        public var usr_ecc_addr_en: USR_ECC_ADDR_EN

        /// 1: The error information in SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR is updated when there is an ECC error. 0: SPI_MEM_ECC_ERR_BITS and SPI_MEM_ECC_ERR_ADDR record the first ECC error information.
        @ReadOnly(bits: 24..<25)
        public var ecc_continue_record_err_en: ECC_CONTINUE_RECORD_ERR_EN

        /// Records the first ECC error bit number in the 16 bytes(From 0~127, corresponding to byte 0 bit 0 to byte 15 bit 7)
        @ReadOnly(bits: 25..<32)
        public var ecc_err_bits: ECC_ERR_BITS
    }

    /// MSPI ECC error address register
    @Register(bitWidth: 32)
    public struct ECC_ERR_ADDR {
        /// This bits show the first MSPI ECC error address. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
        @ReadOnly(bits: 0..<26)
        public var ecc_err_addr_field: ECC_ERR_ADDR_FIELD

        /// This bits show the error times of MSPI ECC read. It is cleared by when SPI_MEM_ECC_ERR_INT_CLR bit is set.
        @ReadOnly(bits: 26..<32)
        public var ecc_err_cnt: ECC_ERR_CNT
    }

    /// SPI0 AXI request error address.
    @Register(bitWidth: 32)
    public struct AXI_ERR_ADDR {
        /// This bits show the first AXI write/read invalid error or AXI write flash error address. It is cleared by when SPI_MEM_AXI_WADDR_ERR_INT_CLR, SPI_MEM_AXI_WR_FLASH_ERR_IN_CLR or SPI_MEM_AXI_RADDR_ERR_IN_CLR bit is set.
        @ReadOnly(bits: 0..<26)
        public var axi_err_addr_field: AXI_ERR_ADDR_FIELD

        /// The empty status of all AFIFO and SYNC_FIFO in MSPI module. 1: All AXI transfers and SPI0 transfers are done. 0: Others.
        @ReadOnly(bits: 26..<27)
        public var all_fifo_empty: ALL_FIFO_EMPTY

        /// 1: RDATA_AFIFO is empty. 0: At least one AXI read transfer is pending.
        @ReadOnly(bits: 27..<28)
        public var spi_rdata_afifo_rempty: SPI_RDATA_AFIFO_REMPTY

        /// 1: AXI_RADDR_CTL_AFIFO is empty. 0: At least one AXI read transfer is pending.
        @ReadOnly(bits: 28..<29)
        public var spi_raddr_afifo_rempty: SPI_RADDR_AFIFO_REMPTY

        /// 1: WDATA_AFIFO is empty. 0: At least one AXI write transfer is pending.
        @ReadOnly(bits: 29..<30)
        public var spi_wdata_afifo_rempty: SPI_WDATA_AFIFO_REMPTY

        /// 1: WBLEN_AFIFO is empty. 0: At least one AXI write transfer is pending.
        @ReadOnly(bits: 30..<31)
        public var spi_wblen_afifo_rempty: SPI_WBLEN_AFIFO_REMPTY

        /// This bit is set when WADDR_AFIFO, WBLEN_AFIFO, WDATA_AFIFO, AXI_RADDR_CTL_AFIFO and RDATA_AFIFO are empty and spi0_mst_st is IDLE.
        @ReadOnly(bits: 31..<32)
        public var spi_all_axi_trans_afifo_empty: SPI_ALL_AXI_TRANS_AFIFO_EMPTY
    }

    /// MSPI ECC control register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_ECC_CTRL {
        /// Set this bit to calculate the error times of MSPI ECC read when accesses to external RAM.
        @ReadOnly(bits: 17..<18)
        public var spi_smem_ecc_err_int_en: SPI_SMEM_ECC_ERR_INT_EN

        /// Set the page size of the external RAM accessed by MSPI. 0: 256 bytes. 1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.
        @ReadOnly(bits: 18..<20)
        public var spi_smem_page_size: SPI_SMEM_PAGE_SIZE

        /// Set this bit to enable MSPI ECC address conversion, no matter MSPI accesses to the ECC region or non-ECC region of external RAM. If there is no ECC region in external RAM, this bit should be 0. Otherwise, this bit should be 1.
        @ReadOnly(bits: 20..<21)
        public var spi_smem_ecc_addr_en: SPI_SMEM_ECC_ADDR_EN
    }

    /// SPI0 flash timing calibration register
    @Register(bitWidth: 32)
    public struct TIMING_CALI {
        /// The bit is used to enable timing adjust clock for all reading operations.
        @ReadWrite(bits: 0..<1)
        public var timing_clk_ena: TIMING_CLK_ENA

        /// The bit is used to enable timing auto-calibration for all reading operations.
        @ReadWrite(bits: 1..<2)
        public var timing_cali_field: TIMING_CALI_FIELD

        /// add extra dummy spi clock cycle length for spi clock calibration.
        @ReadWrite(bits: 2..<5)
        public var extra_dummy_cyclelen: EXTRA_DUMMY_CYCLELEN

        /// Set this bit to enable DLL for timing calibration in DDR mode when accessed to flash.
        @ReadOnly(bits: 5..<6)
        public var dll_timing_cali: DLL_TIMING_CALI

        /// Set this bit to update delay mode, delay num and extra dummy in MSPI.
        @WriteOnly(bits: 6..<7)
        public var update: UPDATE
    }

    /// MSPI flash input timing delay mode control register
    @Register(bitWidth: 32)
    public struct DIN_MODE {
        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadWrite(bits: 0..<3)
        public var din0_mode: DIN0_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadWrite(bits: 3..<6)
        public var din1_mode: DIN1_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadWrite(bits: 6..<9)
        public var din2_mode: DIN2_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadWrite(bits: 9..<12)
        public var din3_mode: DIN3_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        @ReadWrite(bits: 12..<15)
        public var din4_mode: DIN4_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        @ReadWrite(bits: 15..<18)
        public var din5_mode: DIN5_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        @ReadWrite(bits: 18..<21)
        public var din6_mode: DIN6_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        @ReadWrite(bits: 21..<24)
        public var din7_mode: DIN7_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the spi_clk
        @ReadWrite(bits: 24..<27)
        public var dins_mode: DINS_MODE
    }

    /// MSPI flash input timing delay number control register
    @Register(bitWidth: 32)
    public struct DIN_NUM {
        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 0..<2)
        public var din0_num: DIN0_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 2..<4)
        public var din1_num: DIN1_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 4..<6)
        public var din2_num: DIN2_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 6..<8)
        public var din3_num: DIN3_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 8..<10)
        public var din4_num: DIN4_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 10..<12)
        public var din5_num: DIN5_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 12..<14)
        public var din6_num: DIN6_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 14..<16)
        public var din7_num: DIN7_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadWrite(bits: 16..<18)
        public var dins_num: DINS_NUM
    }

    /// MSPI flash output timing adjustment control register
    @Register(bitWidth: 32)
    public struct DOUT_MODE {
        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadWrite(bits: 0..<1)
        public var dout0_mode: DOUT0_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadWrite(bits: 1..<2)
        public var dout1_mode: DOUT1_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadWrite(bits: 2..<3)
        public var dout2_mode: DOUT2_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadWrite(bits: 3..<4)
        public var dout3_mode: DOUT3_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        @ReadWrite(bits: 4..<5)
        public var dout4_mode: DOUT4_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        @ReadWrite(bits: 5..<6)
        public var dout5_mode: DOUT5_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        @ReadWrite(bits: 6..<7)
        public var dout6_mode: DOUT6_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        @ReadWrite(bits: 7..<8)
        public var dout7_mode: DOUT7_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the spi_clk
        @ReadWrite(bits: 8..<9)
        public var douts_mode: DOUTS_MODE
    }

    /// MSPI external RAM timing calibration register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_TIMING_CALI {
        /// For sram, the bit is used to enable timing adjust clock for all reading operations.
        @ReadOnly(bits: 0..<1)
        public var spi_smem_timing_clk_ena: SPI_SMEM_TIMING_CLK_ENA

        /// For sram, the bit is used to enable timing auto-calibration for all reading operations.
        @ReadOnly(bits: 1..<2)
        public var spi_smem_timing_cali_field: SPI_SMEM_TIMING_CALI_FIELD

        /// For sram, add extra dummy spi clock cycle length for spi clock calibration.
        @ReadOnly(bits: 2..<5)
        public var spi_smem_extra_dummy_cyclelen: SPI_SMEM_EXTRA_DUMMY_CYCLELEN

        /// Set this bit to enable DLL for timing calibration in DDR mode when accessed to EXT_RAM.
        @ReadOnly(bits: 5..<6)
        public var spi_smem_dll_timing_cali: SPI_SMEM_DLL_TIMING_CALI
    }

    /// MSPI external RAM input timing delay mode control register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_DIN_MODE {
        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 0..<3)
        public var spi_smem_din0_mode: SPI_SMEM_DIN0_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 3..<6)
        public var spi_smem_din1_mode: SPI_SMEM_DIN1_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 6..<9)
        public var spi_smem_din2_mode: SPI_SMEM_DIN2_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 9..<12)
        public var spi_smem_din3_mode: SPI_SMEM_DIN3_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 12..<15)
        public var spi_smem_din4_mode: SPI_SMEM_DIN4_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 15..<18)
        public var spi_smem_din5_mode: SPI_SMEM_DIN5_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 18..<21)
        public var spi_smem_din6_mode: SPI_SMEM_DIN6_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 21..<24)
        public var spi_smem_din7_mode: SPI_SMEM_DIN7_MODE

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 24..<27)
        public var spi_smem_dins_mode: SPI_SMEM_DINS_MODE
    }

    /// MSPI external RAM input timing delay number control register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_DIN_NUM {
        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 0..<2)
        public var spi_smem_din0_num: SPI_SMEM_DIN0_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 2..<4)
        public var spi_smem_din1_num: SPI_SMEM_DIN1_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 4..<6)
        public var spi_smem_din2_num: SPI_SMEM_DIN2_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 6..<8)
        public var spi_smem_din3_num: SPI_SMEM_DIN3_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 8..<10)
        public var spi_smem_din4_num: SPI_SMEM_DIN4_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 10..<12)
        public var spi_smem_din5_num: SPI_SMEM_DIN5_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 12..<14)
        public var spi_smem_din6_num: SPI_SMEM_DIN6_NUM

        /// the input signals are delayed by system clock cycles, 0: delayed by 1 cycle, 1: delayed by 2 cycles,...
        @ReadOnly(bits: 14..<16)
        public var spi_smem_din7_num: SPI_SMEM_DIN7_NUM

        /// the input signals are delayed by system clock cycles, 0: input without delayed, 1: input with the posedge of clk_apb,2 input with the negedge of clk_apb, 3: input with the posedge of clk_160, 4 input with the negedge of clk_160, 5: input with the spi_clk high edge, 6: input with the spi_clk low edge
        @ReadOnly(bits: 16..<18)
        public var spi_smem_dins_num: SPI_SMEM_DINS_NUM
    }

    /// MSPI external RAM output timing adjustment control register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_DOUT_MODE {
        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 0..<1)
        public var spi_smem_dout0_mode: SPI_SMEM_DOUT0_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 1..<2)
        public var spi_smem_dout1_mode: SPI_SMEM_DOUT1_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 2..<3)
        public var spi_smem_dout2_mode: SPI_SMEM_DOUT2_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 3..<4)
        public var spi_smem_dout3_mode: SPI_SMEM_DOUT3_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 4..<5)
        public var spi_smem_dout4_mode: SPI_SMEM_DOUT4_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 5..<6)
        public var spi_smem_dout5_mode: SPI_SMEM_DOUT5_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 6..<7)
        public var spi_smem_dout6_mode: SPI_SMEM_DOUT6_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 7..<8)
        public var spi_smem_dout7_mode: SPI_SMEM_DOUT7_MODE

        /// the output signals are delayed by system clock cycles, 0: output without delayed, 1: output with the posedge of clk_apb,2 output with the negedge of clk_apb, 3: output with the posedge of clk_160,4 output with the negedge of clk_160,5: output with the spi_clk high edge ,6: output with the spi_clk low edge
        @ReadOnly(bits: 8..<9)
        public var spi_smem_douts_mode: SPI_SMEM_DOUTS_MODE
    }

    /// MSPI external RAM ECC and SPI CS timing control register
    @Register(bitWidth: 32)
    public struct SPI_SMEM_AC {
        /// For SPI0 and SPI1, spi cs is enable when spi is in prepare phase. 1: enable 0: disable.
        @ReadOnly(bits: 0..<1)
        public var spi_smem_cs_setup: SPI_SMEM_CS_SETUP

        /// For SPI0 and SPI1, spi cs keep low when spi is in done phase. 1: enable 0: disable.
        @ReadOnly(bits: 1..<2)
        public var spi_smem_cs_hold: SPI_SMEM_CS_HOLD

        /// For spi0, (cycles-1) of prepare phase by spi clock this bits are combined with spi_mem_cs_setup bit.
        @ReadOnly(bits: 2..<7)
        public var spi_smem_cs_setup_time: SPI_SMEM_CS_SETUP_TIME

        /// For SPI0 and SPI1, spi cs signal is delayed to inactive by spi clock this bits are combined with spi_mem_cs_hold bit.
        @ReadOnly(bits: 7..<12)
        public var spi_smem_cs_hold_time: SPI_SMEM_CS_HOLD_TIME

        /// SPI_SMEM_CS_HOLD_TIME + SPI_SMEM_ECC_CS_HOLD_TIME is the SPI0 and SPI1 CS hold cycles in ECC mode when accessed external RAM.
        @ReadOnly(bits: 12..<15)
        public var spi_smem_ecc_cs_hold_time: SPI_SMEM_ECC_CS_HOLD_TIME

        /// 1: SPI0 skips page corner when accesses external RAM. 0: Not skip page corner when accesses external RAM.
        @ReadOnly(bits: 15..<16)
        public var spi_smem_ecc_skip_page_corner: SPI_SMEM_ECC_SKIP_PAGE_CORNER

        /// Set this bit to enable SPI0 and SPI1 ECC 16 bytes data with 2 ECC bytes mode when accesses external RAM.
        @ReadOnly(bits: 16..<17)
        public var spi_smem_ecc_16to18_byte_en: SPI_SMEM_ECC_16TO18_BYTE_EN

        /// These bits are used to set the minimum CS high time tSHSL between SPI burst transfer when accesses to external RAM. tSHSL is (SPI_SMEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.
        @ReadOnly(bits: 25..<31)
        public var spi_smem_cs_hold_delay: SPI_SMEM_CS_HOLD_DELAY

        /// Set this bit to enable SPI0 split one AXI accesses EXT_RAM transfer into two SPI transfers when one transfer will cross flash/EXT_RAM page corner, valid no matter whether there is an ECC region or not.
        @ReadOnly(bits: 31..<32)
        public var spi_smem_split_trans_en: SPI_SMEM_SPLIT_TRANS_EN
    }

    /// SPI0 clock gate register
    @Register(bitWidth: 32)
    public struct CLOCK_GATE {
        /// Register clock gate enable signal. 1: Enable. 0: Disable.
        @ReadWrite(bits: 0..<1)
        public var spi_clk_en: SPI_CLK_EN
    }

    /// The base address of the memory that stores plaintext in Manual Encryption
    @Register(bitWidth: 32)
    public struct XTS_PLAIN_BASE {
        /// This field is only used to generate include file in c case. This field is useless. Please do not use this field.
        @ReadWrite(bits: 0..<32)
        public var spi_xts_plain: SPI_XTS_PLAIN
    }

    /// Manual Encryption Line-Size register
    @Register(bitWidth: 32)
    public struct XTS_LINESIZE {
        /// This bits stores the line-size parameter which will be used in manual encryption calculation. It decides how many bytes will be encrypted one time. 0: 16-bytes, 1: 32-bytes, 2: 64-bytes, 3:reserved.
        @ReadWrite(bits: 0..<2)
        public var spi_xts_linesize: SPI_XTS_LINESIZE
    }

    /// Manual Encryption destination register
    @Register(bitWidth: 32)
    public struct XTS_DESTINATION {
        /// This bit stores the destination parameter which will be used in manual encryption calculation. 0: flash(default), 1: psram(reserved). Only default value can be used.
        @ReadWrite(bits: 0..<1)
        public var spi_xts_destination: SPI_XTS_DESTINATION
    }

    /// Manual Encryption physical address register
    @Register(bitWidth: 32)
    public struct XTS_PHYSICAL_ADDRESS {
        /// This bits stores the physical-address parameter which will be used in manual encryption calculation. This value should aligned with byte number decided by line-size parameter.
        @ReadWrite(bits: 0..<26)
        public var spi_xts_physical_address: SPI_XTS_PHYSICAL_ADDRESS
    }

    /// Manual Encryption physical address register
    @Register(bitWidth: 32)
    public struct XTS_TRIGGER {
        /// Set this bit to trigger the process of manual encryption calculation. This action should only be asserted when manual encryption status is 0. After this action, manual encryption status becomes 1. After calculation is done, manual encryption status becomes 2.
        @WriteOnly(bits: 0..<1)
        public var spi_xts_trigger: SPI_XTS_TRIGGER
    }

    /// Manual Encryption physical address register
    @Register(bitWidth: 32)
    public struct XTS_RELEASE {
        /// Set this bit to release encrypted result to mspi. This action should only be asserted when manual encryption status is 2. After this action, manual encryption status will become 3.
        @WriteOnly(bits: 0..<1)
        public var spi_xts_release: SPI_XTS_RELEASE
    }

    /// Manual Encryption physical address register
    @Register(bitWidth: 32)
    public struct XTS_DESTROY {
        /// Set this bit to destroy encrypted result. This action should be asserted only when manual encryption status is 3. After this action, manual encryption status will become 0.
        @WriteOnly(bits: 0..<1)
        public var spi_xts_destroy: SPI_XTS_DESTROY
    }

    /// Manual Encryption physical address register
    @Register(bitWidth: 32)
    public struct XTS_STATE {
        /// This bits stores the status of manual encryption. 0: idle, 1: busy of encryption calculation, 2: encryption calculation is done but the encrypted result is invisible to mspi, 3: the encrypted result is visible to mspi.
        @ReadOnly(bits: 0..<2)
        public var spi_xts_state: SPI_XTS_STATE
    }

    /// Manual Encryption version register
    @Register(bitWidth: 32)
    public struct XTS_DATE {
        /// This bits stores the last modified-time of manual encryption feature.
        @ReadWrite(bits: 0..<30)
        public var spi_xts_date: SPI_XTS_DATE
    }

    /// MSPI-MMU item content register
    @Register(bitWidth: 32)
    public struct MMU_ITEM_CONTENT {
        /// MSPI-MMU item content
        @ReadWrite(bits: 0..<32)
        public var spi_mmu_item_content: SPI_MMU_ITEM_CONTENT
    }

    /// MSPI-MMU item index register
    @Register(bitWidth: 32)
    public struct MMU_ITEM_INDEX {
        /// MSPI-MMU item index
        @ReadWrite(bits: 0..<32)
        public var spi_mmu_item_index: SPI_MMU_ITEM_INDEX
    }

    /// MSPI MMU power control register
    @Register(bitWidth: 32)
    public struct MMU_POWER_CTRL {
        /// Set this bit to enable mmu-memory clock force on
        @ReadWrite(bits: 0..<1)
        public var spi_mmu_mem_force_on: SPI_MMU_MEM_FORCE_ON

        /// Set this bit to force mmu-memory powerdown
        @ReadWrite(bits: 1..<2)
        public var spi_mmu_mem_force_pd: SPI_MMU_MEM_FORCE_PD

        /// Set this bit to force mmu-memory powerup, in this case, the power should also be controlled by rtc.
        @ReadWrite(bits: 2..<3)
        public var spi_mmu_mem_force_pu: SPI_MMU_MEM_FORCE_PU

        /// 0: Max page size , 1: Max page size/2 , 2: Max page size/4, 3: Max page size/8
        @ReadWrite(bits: 3..<5)
        public var spi_mmu_page_size: SPI_MMU_PAGE_SIZE

        /// MMU PSRAM aux control register
        @ReadOnly(bits: 16..<30)
        public var aux_ctrl: AUX_CTRL

        /// ECO register enable bit
        @ReadOnly(bits: 30..<31)
        public var rdn_ena: RDN_ENA

        /// MSPI module clock domain and AXI clock domain ECO register result register
        @ReadOnly(bits: 31..<32)
        public var rdn_result: RDN_RESULT
    }

    /// SPI memory cryption DPA register
    @Register(bitWidth: 32)
    public struct DPA_CTRL {
        /// Set the security level of spi mem cryption. 0: Shut off cryption DPA funtion. 1-7: The bigger the number is, the more secure the cryption is. (Note that the performance of cryption will decrease together with this number increasing)
        @ReadWrite(bits: 0..<3)
        public var spi_crypt_security_level: SPI_CRYPT_SECURITY_LEVEL

        /// Only available when SPI_CRYPT_SECURITY_LEVEL is not 0. 1: Enable DPA in the calculation that using key 1 or key 2. 0: Enable DPA only in the calculation that using key 1.
        @ReadWrite(bits: 3..<4)
        public var spi_crypt_calc_d_dpa_en: SPI_CRYPT_CALC_D_DPA_EN

        /// 1: MSPI XTS DPA clock gate is controlled by SPI_CRYPT_CALC_D_DPA_EN and SPI_CRYPT_SECURITY_LEVEL. 0: Controlled by efuse bits.
        @ReadWrite(bits: 4..<5)
        public var spi_crypt_dpa_select_register: SPI_CRYPT_DPA_SELECT_REGISTER
    }

    /// MSPI ECO high register
    @Register(bitWidth: 32)
    public struct REGISTERRND_ECO_HIGH {
        /// ECO high register
        @ReadOnly(bits: 0..<32)
        public var registerrnd_eco_high_field: REGISTERRND_ECO_HIGH_FIELD
    }

    /// MSPI ECO low register
    @Register(bitWidth: 32)
    public struct REGISTERRND_ECO_LOW {
        /// ECO low register
        @ReadOnly(bits: 0..<32)
        public var registerrnd_eco_low_field: REGISTERRND_ECO_LOW_FIELD
    }

    /// SPI0 version control register
    @Register(bitWidth: 32)
    public struct DATE {
        /// SPI0 register version.
        @ReadWrite(bits: 0..<28)
        public var date_field: DATE_FIELD
    }
}
