// Generated by svd2swift.

import MMIO

/// Timer Group 0
@RegisterBlock
public struct TIMG0 {
    /// Watchdog timer configuration register
    @RegisterBlock(offset: 0x48)
    public var wdtconfig0: Register<WDTCONFIG0>

    /// Watchdog timer prescaler register
    @RegisterBlock(offset: 0x4c)
    public var wdtconfig1: Register<WDTCONFIG1>

    /// Watchdog timer stage 0 timeout value
    @RegisterBlock(offset: 0x50)
    public var wdtconfig2: Register<WDTCONFIG2>

    /// Watchdog timer stage 1 timeout value
    @RegisterBlock(offset: 0x54)
    public var wdtconfig3: Register<WDTCONFIG3>

    /// Watchdog timer stage 2 timeout value
    @RegisterBlock(offset: 0x58)
    public var wdtconfig4: Register<WDTCONFIG4>

    /// Watchdog timer stage 3 timeout value
    @RegisterBlock(offset: 0x5c)
    public var wdtconfig5: Register<WDTCONFIG5>

    /// Write to feed the watchdog timer
    @RegisterBlock(offset: 0x60)
    public var wdtfeed: Register<WDTFEED>

    /// Watchdog write protect register
    @RegisterBlock(offset: 0x64)
    public var wdtwprotect: Register<WDTWPROTECT>

    /// RTC calibration configure register
    @RegisterBlock(offset: 0x68)
    public var rtccalicfg: Register<RTCCALICFG>

    /// RTC calibration configure1 register
    @RegisterBlock(offset: 0x6c)
    public var rtccalicfg1: Register<RTCCALICFG1>

    /// Interrupt enable bits
    @RegisterBlock(offset: 0x70)
    public var int_ena: Register<INT_ENA>

    /// Raw interrupt status
    @RegisterBlock(offset: 0x74)
    public var int_raw: Register<INT_RAW>

    /// Masked interrupt status
    @RegisterBlock(offset: 0x78)
    public var int_st: Register<INT_ST>

    /// Interrupt clear bits
    @RegisterBlock(offset: 0x7c)
    public var int_clr: Register<INT_CLR>

    /// Timer group calibration register
    @RegisterBlock(offset: 0x80)
    public var rtccalicfg2: Register<RTCCALICFG2>

    /// Timer version control register
    @RegisterBlock(offset: 0xf8)
    public var ntimers_date: Register<NTIMERS_DATE>

    /// Timer group clock gate register
    @RegisterBlock(offset: 0xfc)
    public var regclk: Register<REGCLK>

    /// Cluster T%s, containing T?CONFIG, T?LO, T?HI, T?UPDATE, T?ALARMLO, T?ALARMHI, T?LOADLO, T?LOADHI, T?LOAD
    @RegisterBlock(offset: 0x0, stride: 0x24, count: 1)
    public var t: RegisterArray<T>
}

extension TIMG0 {
    /// Watchdog timer configuration register
    @Register(bitWidth: 32)
    public struct WDTCONFIG0 {
        /// WDT reset CPU enable.
        @ReadWrite(bits: 12..<13)
        public var wdt_appcpu_reset_en: WDT_APPCPU_RESET_EN

        /// WDT reset CPU enable.
        @ReadWrite(bits: 13..<14)
        public var wdt_procpu_reset_en: WDT_PROCPU_RESET_EN

        /// When set, Flash boot protection is enabled.
        @ReadWrite(bits: 14..<15)
        public var wdt_flashboot_mod_en: WDT_FLASHBOOT_MOD_EN

        /// 2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
        @ReadWrite(bits: 15..<18)
        public var wdt_sys_reset_length: WDT_SYS_RESET_LENGTH

        /// 2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
        @ReadWrite(bits: 18..<21)
        public var wdt_cpu_reset_length: WDT_CPU_RESET_LENGTH

        /// choose WDT clock:0-apb_clk, 1-xtal_clk.
        @ReadWrite(bits: 21..<22)
        public var wdt_use_xtal: WDT_USE_XTAL

        /// update the WDT configuration registers
        @WriteOnly(bits: 22..<23)
        public var wdt_conf_update_en: WDT_CONF_UPDATE_EN

        /// Stage 3 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 23..<25)
        public var wdt_stg3: WDT_STG3

        /// Stage 2 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 25..<27)
        public var wdt_stg2: WDT_STG2

        /// Stage 1 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 27..<29)
        public var wdt_stg1: WDT_STG1

        /// Stage 0 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 29..<31)
        public var wdt_stg0: WDT_STG0

        /// When set, MWDT is enabled.
        @ReadWrite(bits: 31..<32)
        public var wdt_en: WDT_EN
    }

    /// Watchdog timer prescaler register
    @Register(bitWidth: 32)
    public struct WDTCONFIG1 {
        /// When set, WDT 's clock divider counter will be reset.
        @WriteOnly(bits: 0..<1)
        public var wdt_divcnt_rst: WDT_DIVCNT_RST

        /// TIMG_WDT_CLK_PRESCALE.
        @ReadWrite(bits: 16..<32)
        public var wdt_clk_prescale: WDT_CLK_PRESCALE
    }

    /// Watchdog timer stage 0 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG2 {
        /// Stage 0 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg0_hold: WDT_STG0_HOLD
    }

    /// Watchdog timer stage 1 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG3 {
        /// Stage 1 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg1_hold: WDT_STG1_HOLD
    }

    /// Watchdog timer stage 2 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG4 {
        /// Stage 2 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg2_hold: WDT_STG2_HOLD
    }

    /// Watchdog timer stage 3 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG5 {
        /// Stage 3 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg3_hold: WDT_STG3_HOLD
    }

    /// Write to feed the watchdog timer
    @Register(bitWidth: 32)
    public struct WDTFEED {
        /// Write any value to feed the MWDT. (WO)
        @WriteOnly(bits: 0..<32)
        public var wdt_feed: WDT_FEED
    }

    /// Watchdog write protect register
    @Register(bitWidth: 32)
    public struct WDTWPROTECT {
        /// protection is enabled.
        @ReadWrite(bits: 0..<32)
        public var wdt_wkey: WDT_WKEY
    }

    /// RTC calibration configure register
    @Register(bitWidth: 32)
    public struct RTCCALICFG {
        /// 0: one-shot frequency calculation,1: periodic frequency calculation,
        @ReadWrite(bits: 12..<13)
        public var rtc_cali_start_cycling: RTC_CALI_START_CYCLING

        /// 0:rtc slow clock. 1:clk_8m, 2:xtal_32k.
        @ReadWrite(bits: 13..<15)
        public var rtc_cali_clk_sel: RTC_CALI_CLK_SEL

        /// indicate one-shot frequency calculation is done.
        @ReadOnly(bits: 15..<16)
        public var rtc_cali_rdy: RTC_CALI_RDY

        /// Configure the time to calculate RTC slow clock's frequency.
        @ReadWrite(bits: 16..<31)
        public var rtc_cali_max: RTC_CALI_MAX

        /// Set this bit to start one-shot frequency calculation.
        @ReadWrite(bits: 31..<32)
        public var rtc_cali_start: RTC_CALI_START
    }

    /// RTC calibration configure1 register
    @Register(bitWidth: 32)
    public struct RTCCALICFG1 {
        /// indicate periodic frequency calculation is done.
        @ReadOnly(bits: 0..<1)
        public var rtc_cali_cycling_data_vld: RTC_CALI_CYCLING_DATA_VLD

        /// When one-shot or periodic frequency calculation is done, read this value to calculate RTC slow clock's frequency.
        @ReadOnly(bits: 7..<32)
        public var rtc_cali_value: RTC_CALI_VALUE
    }

    /// Interrupt enable bits
    @Register(bitWidth: 32)
    public struct INT_ENA {
        /// The interrupt enable bit for the TIMG_T%s_INT interrupt.
        @ReadWrite(bits: 0..<1)
        public var t0: T0

        /// The interrupt enable bit for the TIMG_WDT_INT interrupt.
        @ReadWrite(bits: 1..<2)
        public var wdt: WDT
    }

    /// Raw interrupt status
    @Register(bitWidth: 32)
    public struct INT_RAW {
        /// The raw interrupt status bit for the TIMG_T%s_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var t0: T0

        /// The raw interrupt status bit for the TIMG_WDT_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var wdt: WDT
    }

    /// Masked interrupt status
    @Register(bitWidth: 32)
    public struct INT_ST {
        /// The masked interrupt status bit for the TIMG_T%s_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var t0: T0

        /// The masked interrupt status bit for the TIMG_WDT_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var wdt: WDT
    }

    /// Interrupt clear bits
    @Register(bitWidth: 32)
    public struct INT_CLR {
        /// Set this bit to clear the TIMG_T%s_INT interrupt.
        @WriteOnly(bits: 0..<1)
        public var t0: T0

        /// Set this bit to clear the TIMG_WDT_INT interrupt.
        @WriteOnly(bits: 1..<2)
        public var wdt: WDT
    }

    /// Timer group calibration register
    @Register(bitWidth: 32)
    public struct RTCCALICFG2 {
        /// RTC calibration timeout indicator
        @ReadOnly(bits: 0..<1)
        public var rtc_cali_timeout: RTC_CALI_TIMEOUT

        /// Cycles that release calibration timeout reset
        @ReadWrite(bits: 3..<7)
        public var rtc_cali_timeout_rst_cnt: RTC_CALI_TIMEOUT_RST_CNT

        /// Threshold value for the RTC calibration timer. If the calibration timer's value exceeds this threshold, a timeout is triggered.
        @ReadWrite(bits: 7..<32)
        public var rtc_cali_timeout_thres: RTC_CALI_TIMEOUT_THRES
    }

    /// Timer version control register
    @Register(bitWidth: 32)
    public struct NTIMERS_DATE {
        /// Timer version control register
        @ReadWrite(bits: 0..<28)
        public var ntimgs_date: NTIMGS_DATE
    }

    /// Timer group clock gate register
    @Register(bitWidth: 32)
    public struct REGCLK {
        /// enable timer's etm task and event
        @ReadWrite(bits: 28..<29)
        public var etm_en: ETM_EN

        /// enable WDT's clock
        @ReadWrite(bits: 29..<30)
        public var wdt_clk_is_active: WDT_CLK_IS_ACTIVE

        /// enable Timer 30's clock
        @ReadWrite(bits: 30..<31)
        public var timer_clk_is_active: TIMER_CLK_IS_ACTIVE

        /// Register clock gate signal. 1: Registers can be read and written to by software. 0: Registers can not be read or written to by software.
        @ReadWrite(bits: 31..<32)
        public var clk_en: CLK_EN
    }

    /// Cluster T%s, containing T?CONFIG, T?LO, T?HI, T?UPDATE, T?ALARMLO, T?ALARMHI, T?LOADLO, T?LOADHI, T?LOAD
    @RegisterBlock
    public struct T {
        /// Timer %s configuration register
        @RegisterBlock(offset: 0x0)
        public var config: Register<CONFIG>

        /// Timer %s current value, low 32 bits
        @RegisterBlock(offset: 0x4)
        public var lo: Register<LO>

        /// Timer %s current value, high 22 bits
        @RegisterBlock(offset: 0x8)
        public var hi: Register<HI>

        /// Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
        @RegisterBlock(offset: 0xc)
        public var update: Register<UPDATE>

        /// Timer %s alarm value, low 32 bits
        @RegisterBlock(offset: 0x10)
        public var alarmlo: Register<ALARMLO>

        /// Timer %s alarm value, high bits
        @RegisterBlock(offset: 0x14)
        public var alarmhi: Register<ALARMHI>

        /// Timer %s reload value, low 32 bits
        @RegisterBlock(offset: 0x18)
        public var loadlo: Register<LOADLO>

        /// Timer %s reload value, high 22 bits
        @RegisterBlock(offset: 0x1c)
        public var loadhi: Register<LOADHI>

        /// Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
        @RegisterBlock(offset: 0x20)
        public var load: Register<LOAD>
    }
}

extension TIMG0.T {
    /// Timer %s configuration register
    @Register(bitWidth: 32)
    public struct CONFIG {
        /// 1: Use XTAL_CLK as the source clock of timer group. 0: Use APB_CLK as the source clock of timer group.
        @ReadWrite(bits: 9..<10)
        public var use_xtal: USE_XTAL

        /// alarm occurs.
        @ReadWrite(bits: 10..<11)
        public var alarm_en: ALARM_EN

        /// When set, Timer %s 's clock divider counter will be reset.
        @WriteOnly(bits: 12..<13)
        public var divcnt_rst: DIVCNT_RST

        /// Timer %s clock (T%s_clk) prescaler value.
        @ReadWrite(bits: 13..<29)
        public var divider: DIVIDER

        /// When set, timer %s auto-reload at alarm is enabled.
        @ReadWrite(bits: 29..<30)
        public var autoreload: AUTORELOAD

        /// cleared, the timer %s time-base counter will decrement.
        @ReadWrite(bits: 30..<31)
        public var increase: INCREASE

        /// When set, the timer %s time-base counter is enabled.
        @ReadWrite(bits: 31..<32)
        public var en: EN
    }

    /// Timer %s current value, low 32 bits
    @Register(bitWidth: 32)
    public struct LO {
        /// of timer %s can be read here.
        @ReadOnly(bits: 0..<32)
        public var lo_field: LO_FIELD
    }

    /// Timer %s current value, high 22 bits
    @Register(bitWidth: 32)
    public struct HI {
        /// of timer %s can be read here.
        @ReadOnly(bits: 0..<22)
        public var hi_field: HI_FIELD
    }

    /// Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
    @Register(bitWidth: 32)
    public struct UPDATE {
        /// After writing 0 or 1 to TIMG_T%sUPDATE_REG, the counter value is latched.
        @ReadWrite(bits: 31..<32)
        public var update_field: UPDATE_FIELD
    }

    /// Timer %s alarm value, low 32 bits
    @Register(bitWidth: 32)
    public struct ALARMLO {
        /// Timer %s alarm trigger time-base counter value, low 32 bits.
        @ReadWrite(bits: 0..<32)
        public var alarm_lo: ALARM_LO
    }

    /// Timer %s alarm value, high bits
    @Register(bitWidth: 32)
    public struct ALARMHI {
        /// Timer %s alarm trigger time-base counter value, high 22 bits.
        @ReadWrite(bits: 0..<22)
        public var alarm_hi: ALARM_HI
    }

    /// Timer %s reload value, low 32 bits
    @Register(bitWidth: 32)
    public struct LOADLO {
        /// Counter.
        @ReadWrite(bits: 0..<32)
        public var load_lo: LOAD_LO
    }

    /// Timer %s reload value, high 22 bits
    @Register(bitWidth: 32)
    public struct LOADHI {
        /// counter.
        @ReadWrite(bits: 0..<22)
        public var load_hi: LOAD_HI
    }

    /// Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
    @Register(bitWidth: 32)
    public struct LOAD {
        /// Write any value to trigger a timer %s time-base counter reload.
        @WriteOnly(bits: 0..<32)
        public var load_field: LOAD_FIELD
    }
}
