// Generated by svd2swift.

import MMIO

/// Timer Group 0
@RegisterBlock
public struct TIMG0 {
    /// Timer %s configuration register
    @RegisterBlock(offset: 0x0)
    public var tconfig: Register<TCONFIG>

    /// Timer %s current value, low 32 bits
    @RegisterBlock(offset: 0x4)
    public var tlo: Register<TLO>

    /// Timer %s current value, high 22 bits
    @RegisterBlock(offset: 0x8)
    public var thi: Register<THI>

    /// Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
    @RegisterBlock(offset: 0xc)
    public var tupdate: Register<TUPDATE>

    /// Timer %s alarm value, low 32 bits
    @RegisterBlock(offset: 0x10)
    public var talarmlo: Register<TALARMLO>

    /// Timer %s alarm value, high bits
    @RegisterBlock(offset: 0x14)
    public var talarmhi: Register<TALARMHI>

    /// Timer %s reload value, low 32 bits
    @RegisterBlock(offset: 0x18)
    public var tloadlo: Register<TLOADLO>

    /// Timer %s reload value, high 22 bits
    @RegisterBlock(offset: 0x1c)
    public var tloadhi: Register<TLOADHI>

    /// Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
    @RegisterBlock(offset: 0x20)
    public var tload: Register<TLOAD>

    /// Watchdog timer configuration register
    @RegisterBlock(offset: 0x48)
    public var wdtconfig0: Register<WDTCONFIG0>

    /// Watchdog timer prescaler register
    @RegisterBlock(offset: 0x4c)
    public var wdtconfig1: Register<WDTCONFIG1>

    /// Watchdog timer stage 0 timeout value
    @RegisterBlock(offset: 0x50)
    public var wdtconfig2: Register<WDTCONFIG2>

    /// Watchdog timer stage 1 timeout value
    @RegisterBlock(offset: 0x54)
    public var wdtconfig3: Register<WDTCONFIG3>

    /// Watchdog timer stage 2 timeout value
    @RegisterBlock(offset: 0x58)
    public var wdtconfig4: Register<WDTCONFIG4>

    /// Watchdog timer stage 3 timeout value
    @RegisterBlock(offset: 0x5c)
    public var wdtconfig5: Register<WDTCONFIG5>

    /// Write to feed the watchdog timer
    @RegisterBlock(offset: 0x60)
    public var wdtfeed: Register<WDTFEED>

    /// Watchdog write protect register
    @RegisterBlock(offset: 0x64)
    public var wdtwprotect: Register<WDTWPROTECT>

    /// RTC calibration configure register
    @RegisterBlock(offset: 0x68)
    public var rtccalicfg: Register<RTCCALICFG>

    /// RTC calibration configure1 register
    @RegisterBlock(offset: 0x6c)
    public var rtccalicfg1: Register<RTCCALICFG1>

    /// Interrupt enable bits
    @RegisterBlock(offset: 0x70)
    public var int_ena_timers: Register<INT_ENA_TIMERS>

    /// Raw interrupt status
    @RegisterBlock(offset: 0x74)
    public var int_raw_timers: Register<INT_RAW_TIMERS>

    /// Masked interrupt status
    @RegisterBlock(offset: 0x78)
    public var int_st_timers: Register<INT_ST_TIMERS>

    /// Interrupt clear bits
    @RegisterBlock(offset: 0x7c)
    public var int_clr_timers: Register<INT_CLR_TIMERS>

    /// Timer group calibration register
    @RegisterBlock(offset: 0x80)
    public var rtccalicfg2: Register<RTCCALICFG2>

    /// Timer version control register
    @RegisterBlock(offset: 0xf8)
    public var ntimers_date: Register<NTIMERS_DATE>

    /// Timer group clock gate register
    @RegisterBlock(offset: 0xfc)
    public var regclk: Register<REGCLK>
}

extension TIMG0 {
    /// Timer %s configuration register
    @Register(bitWidth: 32)
    public struct TCONFIG {
        /// 1: Use XTAL_CLK as the source clock of timer group. 0: Use APB_CLK as the source clock of timer group.
        @ReadWrite(bits: 9..<10)
        public var t_use_xtal: T_USE_XTAL

        /// alarm occurs.
        @ReadWrite(bits: 10..<11)
        public var t_alarm_en: T_ALARM_EN

        /// When set, Timer %s 's clock divider counter will be reset.
        @WriteOnly(bits: 12..<13)
        public var t_divcnt_rst: T_DIVCNT_RST

        /// Timer %s clock (T%s_clk) prescaler value.
        @ReadWrite(bits: 13..<29)
        public var t_divider: T_DIVIDER

        /// When set, timer %s auto-reload at alarm is enabled.
        @ReadWrite(bits: 29..<30)
        public var t_autoreload: T_AUTORELOAD

        /// cleared, the timer %s time-base counter will decrement.
        @ReadWrite(bits: 30..<31)
        public var t_increase: T_INCREASE

        /// When set, the timer %s time-base counter is enabled.
        @ReadWrite(bits: 31..<32)
        public var t_en: T_EN
    }

    /// Timer %s current value, low 32 bits
    @Register(bitWidth: 32)
    public struct TLO {
        /// of timer %s can be read here.
        @ReadOnly(bits: 0..<32)
        public var t_lo: T_LO
    }

    /// Timer %s current value, high 22 bits
    @Register(bitWidth: 32)
    public struct THI {
        /// of timer %s can be read here.
        @ReadOnly(bits: 0..<22)
        public var t_hi: T_HI
    }

    /// Write to copy current timer value to TIMGn_T%s_(LO/HI)_REG
    @Register(bitWidth: 32)
    public struct TUPDATE {
        /// After writing 0 or 1 to TIMG_T%sUPDATE_REG, the counter value is latched.
        @ReadWrite(bits: 31..<32)
        public var t_update: T_UPDATE
    }

    /// Timer %s alarm value, low 32 bits
    @Register(bitWidth: 32)
    public struct TALARMLO {
        /// Timer %s alarm trigger time-base counter value, low 32 bits.
        @ReadWrite(bits: 0..<32)
        public var t_alarm_lo: T_ALARM_LO
    }

    /// Timer %s alarm value, high bits
    @Register(bitWidth: 32)
    public struct TALARMHI {
        /// Timer %s alarm trigger time-base counter value, high 22 bits.
        @ReadWrite(bits: 0..<22)
        public var t_alarm_hi: T_ALARM_HI
    }

    /// Timer %s reload value, low 32 bits
    @Register(bitWidth: 32)
    public struct TLOADLO {
        /// Counter.
        @ReadWrite(bits: 0..<32)
        public var t_load_lo: T_LOAD_LO
    }

    /// Timer %s reload value, high 22 bits
    @Register(bitWidth: 32)
    public struct TLOADHI {
        /// counter.
        @ReadWrite(bits: 0..<22)
        public var t_load_hi: T_LOAD_HI
    }

    /// Write to reload timer from TIMG_T%s_(LOADLOLOADHI)_REG
    @Register(bitWidth: 32)
    public struct TLOAD {
        /// Write any value to trigger a timer %s time-base counter reload.
        @WriteOnly(bits: 0..<32)
        public var t_load: T_LOAD
    }

    /// Watchdog timer configuration register
    @Register(bitWidth: 32)
    public struct WDTCONFIG0 {
        /// WDT reset CPU enable.
        @ReadWrite(bits: 12..<13)
        public var wdt_appcpu_reset_en: WDT_APPCPU_RESET_EN

        /// WDT reset CPU enable.
        @ReadWrite(bits: 13..<14)
        public var wdt_procpu_reset_en: WDT_PROCPU_RESET_EN

        /// When set, Flash boot protection is enabled.
        @ReadWrite(bits: 14..<15)
        public var wdt_flashboot_mod_en: WDT_FLASHBOOT_MOD_EN

        /// 2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
        @ReadWrite(bits: 15..<18)
        public var wdt_sys_reset_length: WDT_SYS_RESET_LENGTH

        /// 2: 300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2 us.
        @ReadWrite(bits: 18..<21)
        public var wdt_cpu_reset_length: WDT_CPU_RESET_LENGTH

        /// choose WDT clock:0-apb_clk, 1-xtal_clk.
        @ReadWrite(bits: 21..<22)
        public var wdt_use_xtal: WDT_USE_XTAL

        /// update the WDT configuration registers
        @WriteOnly(bits: 22..<23)
        public var wdt_conf_update_en: WDT_CONF_UPDATE_EN

        /// Stage 3 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 23..<25)
        public var wdt_stg3: WDT_STG3

        /// Stage 2 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 25..<27)
        public var wdt_stg2: WDT_STG2

        /// Stage 1 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 27..<29)
        public var wdt_stg1: WDT_STG1

        /// Stage 0 configuration. 0: off, 1: interrupt, 2: reset CPU, 3: reset system.
        @ReadWrite(bits: 29..<31)
        public var wdt_stg0: WDT_STG0

        /// When set, MWDT is enabled.
        @ReadWrite(bits: 31..<32)
        public var wdt_en: WDT_EN
    }

    /// Watchdog timer prescaler register
    @Register(bitWidth: 32)
    public struct WDTCONFIG1 {
        /// When set, WDT 's clock divider counter will be reset.
        @WriteOnly(bits: 0..<1)
        public var wdt_divcnt_rst: WDT_DIVCNT_RST

        /// TIMG_WDT_CLK_PRESCALE.
        @ReadWrite(bits: 16..<32)
        public var wdt_clk_prescale: WDT_CLK_PRESCALE
    }

    /// Watchdog timer stage 0 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG2 {
        /// Stage 0 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg0_hold: WDT_STG0_HOLD
    }

    /// Watchdog timer stage 1 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG3 {
        /// Stage 1 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg1_hold: WDT_STG1_HOLD
    }

    /// Watchdog timer stage 2 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG4 {
        /// Stage 2 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg2_hold: WDT_STG2_HOLD
    }

    /// Watchdog timer stage 3 timeout value
    @Register(bitWidth: 32)
    public struct WDTCONFIG5 {
        /// Stage 3 timeout value, in MWDT clock cycles.
        @ReadWrite(bits: 0..<32)
        public var wdt_stg3_hold: WDT_STG3_HOLD
    }

    /// Write to feed the watchdog timer
    @Register(bitWidth: 32)
    public struct WDTFEED {
        /// Write any value to feed the MWDT. (WO)
        @WriteOnly(bits: 0..<32)
        public var wdt_feed: WDT_FEED
    }

    /// Watchdog write protect register
    @Register(bitWidth: 32)
    public struct WDTWPROTECT {
        /// protection is enabled.
        @ReadWrite(bits: 0..<32)
        public var wdt_wkey: WDT_WKEY
    }

    /// RTC calibration configure register
    @Register(bitWidth: 32)
    public struct RTCCALICFG {
        /// 0: one-shot frequency calculation,1: periodic frequency calculation,
        @ReadWrite(bits: 12..<13)
        public var rtc_cali_start_cycling: RTC_CALI_START_CYCLING

        /// 0:rtc slow clock. 1:clk_8m, 2:xtal_32k.
        @ReadWrite(bits: 13..<15)
        public var rtc_cali_clk_sel: RTC_CALI_CLK_SEL

        /// indicate one-shot frequency calculation is done.
        @ReadOnly(bits: 15..<16)
        public var rtc_cali_rdy: RTC_CALI_RDY

        /// Configure the time to calculate RTC slow clock's frequency.
        @ReadWrite(bits: 16..<31)
        public var rtc_cali_max: RTC_CALI_MAX

        /// Set this bit to start one-shot frequency calculation.
        @ReadWrite(bits: 31..<32)
        public var rtc_cali_start: RTC_CALI_START
    }

    /// RTC calibration configure1 register
    @Register(bitWidth: 32)
    public struct RTCCALICFG1 {
        /// indicate periodic frequency calculation is done.
        @ReadOnly(bits: 0..<1)
        public var rtc_cali_cycling_data_vld: RTC_CALI_CYCLING_DATA_VLD

        /// When one-shot or periodic frequency calculation is done, read this value to calculate RTC slow clock's frequency.
        @ReadOnly(bits: 7..<32)
        public var rtc_cali_value: RTC_CALI_VALUE
    }

    /// Interrupt enable bits
    @Register(bitWidth: 32)
    public struct INT_ENA_TIMERS {
        /// The interrupt enable bit for the TIMG_T0_INT interrupt.
        @ReadWrite(bits: 0..<1)
        public var t0_int_ena: T0_INT_ENA

        /// The interrupt enable bit for the TIMG_WDT_INT interrupt.
        @ReadWrite(bits: 1..<2)
        public var wdt_int_ena: WDT_INT_ENA
    }

    /// Raw interrupt status
    @Register(bitWidth: 32)
    public struct INT_RAW_TIMERS {
        /// The raw interrupt status bit for the TIMG_T0_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var t0_int_raw: T0_INT_RAW

        /// The raw interrupt status bit for the TIMG_WDT_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var wdt_int_raw: WDT_INT_RAW
    }

    /// Masked interrupt status
    @Register(bitWidth: 32)
    public struct INT_ST_TIMERS {
        /// The masked interrupt status bit for the TIMG_T0_INT interrupt.
        @ReadOnly(bits: 0..<1)
        public var t0_int_st: T0_INT_ST

        /// The masked interrupt status bit for the TIMG_WDT_INT interrupt.
        @ReadOnly(bits: 1..<2)
        public var wdt_int_st: WDT_INT_ST
    }

    /// Interrupt clear bits
    @Register(bitWidth: 32)
    public struct INT_CLR_TIMERS {
        /// Set this bit to clear the TIMG_T0_INT interrupt.
        @WriteOnly(bits: 0..<1)
        public var t0_int_clr: T0_INT_CLR

        /// Set this bit to clear the TIMG_WDT_INT interrupt.
        @WriteOnly(bits: 1..<2)
        public var wdt_int_clr: WDT_INT_CLR
    }

    /// Timer group calibration register
    @Register(bitWidth: 32)
    public struct RTCCALICFG2 {
        /// RTC calibration timeout indicator
        @ReadOnly(bits: 0..<1)
        public var rtc_cali_timeout: RTC_CALI_TIMEOUT

        /// Cycles that release calibration timeout reset
        @ReadWrite(bits: 3..<7)
        public var rtc_cali_timeout_rst_cnt: RTC_CALI_TIMEOUT_RST_CNT

        /// Threshold value for the RTC calibration timer. If the calibration timer's value exceeds this threshold, a timeout is triggered.
        @ReadWrite(bits: 7..<32)
        public var rtc_cali_timeout_thres: RTC_CALI_TIMEOUT_THRES
    }

    /// Timer version control register
    @Register(bitWidth: 32)
    public struct NTIMERS_DATE {
        /// Timer version control register
        @ReadWrite(bits: 0..<28)
        public var ntimgs_date: NTIMGS_DATE
    }

    /// Timer group clock gate register
    @Register(bitWidth: 32)
    public struct REGCLK {
        /// enable timer's etm task and event
        @ReadWrite(bits: 28..<29)
        public var etm_en: ETM_EN

        /// enable WDT's clock
        @ReadWrite(bits: 29..<30)
        public var wdt_clk_is_active: WDT_CLK_IS_ACTIVE

        /// enable Timer 30's clock
        @ReadWrite(bits: 30..<31)
        public var timer_clk_is_active: TIMER_CLK_IS_ACTIVE

        /// Register clock gate signal. 1: Registers can be read and written to by software. 0: Registers can not be read or written to by software.
        @ReadWrite(bits: 31..<32)
        public var clk_en: CLK_EN
    }
}
